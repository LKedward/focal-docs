{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Focal Documentation Site Focal is a modern Fortran module library which wraps calls to the OpenCL runtime API (using clfortran ) with a higher abstraction level appropriate to the Fortran language. In particular, Focal removes all references to c pointers and provides compact but extensible subroutine wrappers to the OpenCL runtime API. Moreover, Focal introduces typed buffer objects in host code which abstracts byte allocation away while providing built-in type safety. Focal also provides a customisable error handler for OpenCL API errors as well as a debug version containing useful runtime checks for ensuring OpenCL program validity. Project status: v1.0.1 Stable release Github: github.com/lkedward/focal License: MIT Prerequisites: GNU make utility Fortran compiler supporting the 2008 standard (tested regularly with gfortran 7.4.0 & 9.1.0 and ifort 19.1.0 ) An OpenCL development library (One of: Intel OpenCL SDK , NVIDIA CUDA Toolkit , AMD Radeon Software ) Getting started Building the Focal Library Using and linking Focal Quickstart programming guide Example programs Lattice Boltzmann demo Main features Removes use of c pointers to call OpenCL API Provides a level of type safety using typed buffer objects Decreases verbosity of OpenCL API calls while still providing the same functionality Abstracts away low level details, such as size in bytes Contains built-in customisable error handling for all OpenCL API calls Contains built-in 'debug' mode for checking program correctness Contains build-in routines for collecting and presented profiling information Quick example The following Fortran program calculates the sum of two large arrays using an OpenCL kernel. program sum !! Focal example program: calculate the sum of two arrays on an openCL device use Focal implicit none integer , parameter :: Nelem = 1E6 ! No. of array elements real , parameter :: sumVal = 1 0.0 ! Target value for array sum integer :: i ! Counter variable character (:), allocatable :: kernelSrc ! Kernel source string type ( fclDevice ) :: device ! Device object type ( fclProgram ) :: prog ! Focal program object type ( fclKernel ) :: sumKernel ! Focal kernel object real :: array1 ( Nelem ) ! Host array 1 real :: array2 ( Nelem ) ! Host array 2 type ( fclDeviceFloat ) :: array1_d ! Device array 1 type ( fclDeviceFloat ) :: array2_d ! Device array 2 ! Select device with most cores and create command queue device = fclInit ( vendor = 'nvidia' , sortBy = 'cores' ) call fclSetDefaultCommandQ ( fclCreateCommandQ ( device , enableProfiling = . true .)) ! Load kernel from file and compile call fclSourceFromFile ( 'examples/sum.cl' , kernelSrc ) prog = fclCompileProgram ( kernelSrc ) sumKernel = fclGetProgramKernel ( prog , 'sum' ) ! Initialise device arrays call fclInitBuffer ( array1_d , Nelem ) call fclInitBuffer ( array2_d , Nelem ) ! Initialise host array data do i = 1 , Nelem array1 ( i ) = i end do array2 = sumVal - array1 ! Copy data to device array1_d = array1 array2_d = array2 ! Set global work size equal to array length and launch kernel sumKernel % global_work_size ( 1 ) = Nelem call sumKernel % launch ( Nelem , array1_d , array2_d ) ! Copy result back to host and print out to check array2 = array2_d write ( * , * ) array2 ( 1 ), array2 ( size ( array2 , 1 )) end program sum Where sum.cl contains the following openCL kernel: __kernel void sum ( const int nElem , const __global float * v1 , __global float * v2 ){ int i = get_global_id ( 0 ); if ( i < nElem ) v2 [ i ] += v1 [ i ]; }","title":"Home"},{"location":"#focal-documentation-site","text":"Focal is a modern Fortran module library which wraps calls to the OpenCL runtime API (using clfortran ) with a higher abstraction level appropriate to the Fortran language. In particular, Focal removes all references to c pointers and provides compact but extensible subroutine wrappers to the OpenCL runtime API. Moreover, Focal introduces typed buffer objects in host code which abstracts byte allocation away while providing built-in type safety. Focal also provides a customisable error handler for OpenCL API errors as well as a debug version containing useful runtime checks for ensuring OpenCL program validity. Project status: v1.0.1 Stable release Github: github.com/lkedward/focal License: MIT Prerequisites: GNU make utility Fortran compiler supporting the 2008 standard (tested regularly with gfortran 7.4.0 & 9.1.0 and ifort 19.1.0 ) An OpenCL development library (One of: Intel OpenCL SDK , NVIDIA CUDA Toolkit , AMD Radeon Software )","title":"Focal Documentation Site"},{"location":"#getting-started","text":"Building the Focal Library Using and linking Focal Quickstart programming guide Example programs Lattice Boltzmann demo","title":"Getting started"},{"location":"#main-features","text":"Removes use of c pointers to call OpenCL API Provides a level of type safety using typed buffer objects Decreases verbosity of OpenCL API calls while still providing the same functionality Abstracts away low level details, such as size in bytes Contains built-in customisable error handling for all OpenCL API calls Contains built-in 'debug' mode for checking program correctness Contains build-in routines for collecting and presented profiling information","title":"Main features"},{"location":"#quick-example","text":"The following Fortran program calculates the sum of two large arrays using an OpenCL kernel. program sum !! Focal example program: calculate the sum of two arrays on an openCL device use Focal implicit none integer , parameter :: Nelem = 1E6 ! No. of array elements real , parameter :: sumVal = 1 0.0 ! Target value for array sum integer :: i ! Counter variable character (:), allocatable :: kernelSrc ! Kernel source string type ( fclDevice ) :: device ! Device object type ( fclProgram ) :: prog ! Focal program object type ( fclKernel ) :: sumKernel ! Focal kernel object real :: array1 ( Nelem ) ! Host array 1 real :: array2 ( Nelem ) ! Host array 2 type ( fclDeviceFloat ) :: array1_d ! Device array 1 type ( fclDeviceFloat ) :: array2_d ! Device array 2 ! Select device with most cores and create command queue device = fclInit ( vendor = 'nvidia' , sortBy = 'cores' ) call fclSetDefaultCommandQ ( fclCreateCommandQ ( device , enableProfiling = . true .)) ! Load kernel from file and compile call fclSourceFromFile ( 'examples/sum.cl' , kernelSrc ) prog = fclCompileProgram ( kernelSrc ) sumKernel = fclGetProgramKernel ( prog , 'sum' ) ! Initialise device arrays call fclInitBuffer ( array1_d , Nelem ) call fclInitBuffer ( array2_d , Nelem ) ! Initialise host array data do i = 1 , Nelem array1 ( i ) = i end do array2 = sumVal - array1 ! Copy data to device array1_d = array1 array2_d = array2 ! Set global work size equal to array length and launch kernel sumKernel % global_work_size ( 1 ) = Nelem call sumKernel % launch ( Nelem , array1_d , array2_d ) ! Copy result back to host and print out to check array2 = array2_d write ( * , * ) array2 ( 1 ), array2 ( size ( array2 , 1 )) end program sum Where sum.cl contains the following openCL kernel: __kernel void sum ( const int nElem , const __global float * v1 , __global float * v2 ){ int i = get_global_id ( 0 ); if ( i < nElem ) v2 [ i ] += v1 [ i ]; }","title":"Quick example"},{"location":"about/","text":"About The goal of Focal is to provide a concise and accessible Fortran interface to the OpenCL API while retaining the full functionality thereof. This is desirable in Fortran which as a language provides a higher level of abstraction than C; importantly this allows scientists and engineers to focus on their domain specific problem rather than details of low-level implementation. The aims for Focal in particular are to: remove the need to use c pointers in Fortran for the OpenCL API; provide some level of type-safety through the use of typed buffer objects; decrease the verbosity of the API calls while still providing the same functionality; abstract away low-level details, such as buffer size in bytes, not appropriate to Fortran; make it easier to write, debug and profile OpenCL programs. Focal supports a subset of OpenCL v1.2 features. See also Lattice Boltzmann demo Oclgrind (OpenCL device simulator and debugger) Khronos group International workshop on OpenCL OpenCL specification Hands on OpenCL (Complete course with code examples) clfortran project (Fortran interface header library) NVIDIA OpenCL Best Practices NVIDIA OpenCL programming Intel OpenCl optimization guide for intel graphics AMD OpenCL guide","title":"About"},{"location":"about/#about","text":"The goal of Focal is to provide a concise and accessible Fortran interface to the OpenCL API while retaining the full functionality thereof. This is desirable in Fortran which as a language provides a higher level of abstraction than C; importantly this allows scientists and engineers to focus on their domain specific problem rather than details of low-level implementation. The aims for Focal in particular are to: remove the need to use c pointers in Fortran for the OpenCL API; provide some level of type-safety through the use of typed buffer objects; decrease the verbosity of the API calls while still providing the same functionality; abstract away low-level details, such as buffer size in bytes, not appropriate to Fortran; make it easier to write, debug and profile OpenCL programs. Focal supports a subset of OpenCL v1.2 features.","title":"About"},{"location":"about/#see-also","text":"Lattice Boltzmann demo Oclgrind (OpenCL device simulator and debugger) Khronos group International workshop on OpenCL OpenCL specification Hands on OpenCL (Complete course with code examples) clfortran project (Fortran interface header library) NVIDIA OpenCL Best Practices NVIDIA OpenCL programming Intel OpenCl optimization guide for intel graphics AMD OpenCL guide","title":"See also"},{"location":"advanced/","text":"Advanced topics 1. Sub-buffers Sub-buffers are separate buffer objects that reference a single contiguous slice of an existing device buffer. Once initialised they behave like any other device buffer object. Interfaces: call fclInitSubBuffer ([ cmdQ ], untypedSubBuffer , sourceBuffer , offset , size , & [ profileName ],[ access ]) call fclInitSubBuffer ([ cmdQ ], typedSubBuffer , sourceBuffer , start , length , & [ profileName ],[ access ]) cmdQ ( optional ) specifies the command queue to which this buffer is associated. All buffer operations will occur on this command queue. cmdQ can be omitted if the default command queue has been set. untypedSubBuffer ( type(fclDeviceBuffer) ): a general buffer object with no associated type information. typedSubBuffer : can be one of type(fclDeviceInt32) , type(fclDeviceFloat) , type(fclDeviceDouble) . offset ( integer ): the zero-based byte offset within the source buffer at which the sub-buffer starts. size ( integer ): the size in bytes of the sub-buffer. start ( integer ): the zero-based element offset within the source buffer at which the sub-buffer starts. length ( integer ): the number of elements in the sub-buffer. profileName ( character(*) , optional ): descriptive name for printing profiling information. See profiling . access (one of 'r' , 'w' , 'rw' , optional ): kernel read/write access to buffer, default 'rw' . Example: type ( fclDeviceFloat ) :: parentFloat , childFloat ... call fclInitBuffer ( parentFloat , 10 ) call fclInitSubBuffer ( childFloat , parentFloat , 5 , 5 ) In this example, the childFloat sub-buffer references the second half of the parentFloat buffer which contains 10 elements in total. API ref: fclInitSubBuffer 2. Pinned host memory Pinned memory refers to non-pageable memory allocated on the host; this memory can be accessed more directly by devices since it is guaranteed not to have been ' paged-out ' by the host operating system. Pinned memory therefore allows for both faster host-device transfers as well as being required for asynchronous transfers . Pinned memory is implemented in OpenCL using the clEnqueueMapBuffer command which maps a region of allocated ' host accessible ' memory to the host address space and returns a pointer to the host address. 2.1 Allocate pinned memory To use pinned host memory in Focal, simply replace a standard dynamic allocation ( e.g. allocate(hostArray(N)) ) with the fclAllocHost command: Interfaces: call fclAllocHost ( cmdQ , ptr , dim ) call fclAllocHost ( ptr , dim ) cmdQ is the command queue onto which to enqueue the OpenCL map command. As usual, when cmdQ is not specified the default command queue is assumed. ptr is one of: real(sp), pointer, dimension(:) real(dp), pointer, dimension(:) integer, pointer, dimension(:) where sp and dp refer to single precision and double precision kinds respectively. Note that once allocated, ptr can be treated as any other allocatable Fortran array except that it cannot be deallocated using deallocate . dim is the number of elements for which to allocate space for. Note fclAllocHost is a blocking command: execution pauses on the host until the OpenCL map command has completed. Example: Allocate a one-dimensional float array of ten elements using pinned memory on the default command queue. real , pointer :: pinnedArray (:) ... call fclAllocHost ( pinnedArray , 10 ) API ref: fclAllocHost 2.2 Deallocate pinned memory Pinned memory is implemented using pointers and is hence not automatically freed when it goes out of scope. Therefore it must be explicitly deallocated using fclFreeHost when no longer required. Interface: call fclFreeHost ( cmdq , ptr ) call fclFreeHost ( ptr ) cmdQ is the command queue onto which to enqueue the OpenCL unmap command. As usual, when cmdQ is not specified the default command queue is assumed. where ptr is any pointer allocated using fclAllocHost . Note fclFreeHost is a blocking command: execution pauses on the host until the OpenCL unmap command has completed. API ref: fclFreeHost 3. Local kernel arguments If a kernel has a local memory argument, then the functions fclLocalInt32 , fclLocalFloat and fclLocalDouble can be used to supply an argument with a specific dimension. Local memory arguments don't pass data to the kernel, they act like temporary variable length arrays where the size of the array can be specified at kernel launch time. Example The following OpenCL kernel has a local memory argument as the third argument: __kernel void myKernel ( const int size , __global float * vec , __local float * temp ){ int ii = get_global_id ( 0 ); int jj = get_local_id ( 0 ); temp [ jj ] = vec [ ii ] ... } To launch this kernel with Focal, we use: myKernel % launch ( nElem , deviceArray , fclLocalFloat ( localSize ) ) where localSize specifies the size of the local argument float array. API ref: fclLocalInt32 , fclLocalFloat , fclLocalDouble , fclLocalArgument ,","title":"Advanced topics"},{"location":"advanced/#advanced-topics","text":"","title":"Advanced topics"},{"location":"advanced/#1-sub-buffers","text":"Sub-buffers are separate buffer objects that reference a single contiguous slice of an existing device buffer. Once initialised they behave like any other device buffer object. Interfaces: call fclInitSubBuffer ([ cmdQ ], untypedSubBuffer , sourceBuffer , offset , size , & [ profileName ],[ access ]) call fclInitSubBuffer ([ cmdQ ], typedSubBuffer , sourceBuffer , start , length , & [ profileName ],[ access ]) cmdQ ( optional ) specifies the command queue to which this buffer is associated. All buffer operations will occur on this command queue. cmdQ can be omitted if the default command queue has been set. untypedSubBuffer ( type(fclDeviceBuffer) ): a general buffer object with no associated type information. typedSubBuffer : can be one of type(fclDeviceInt32) , type(fclDeviceFloat) , type(fclDeviceDouble) . offset ( integer ): the zero-based byte offset within the source buffer at which the sub-buffer starts. size ( integer ): the size in bytes of the sub-buffer. start ( integer ): the zero-based element offset within the source buffer at which the sub-buffer starts. length ( integer ): the number of elements in the sub-buffer. profileName ( character(*) , optional ): descriptive name for printing profiling information. See profiling . access (one of 'r' , 'w' , 'rw' , optional ): kernel read/write access to buffer, default 'rw' . Example: type ( fclDeviceFloat ) :: parentFloat , childFloat ... call fclInitBuffer ( parentFloat , 10 ) call fclInitSubBuffer ( childFloat , parentFloat , 5 , 5 ) In this example, the childFloat sub-buffer references the second half of the parentFloat buffer which contains 10 elements in total. API ref: fclInitSubBuffer","title":"1. Sub-buffers"},{"location":"advanced/#2-pinned-host-memory","text":"Pinned memory refers to non-pageable memory allocated on the host; this memory can be accessed more directly by devices since it is guaranteed not to have been ' paged-out ' by the host operating system. Pinned memory therefore allows for both faster host-device transfers as well as being required for asynchronous transfers . Pinned memory is implemented in OpenCL using the clEnqueueMapBuffer command which maps a region of allocated ' host accessible ' memory to the host address space and returns a pointer to the host address.","title":"2. Pinned host memory"},{"location":"advanced/#21-allocate-pinned-memory","text":"To use pinned host memory in Focal, simply replace a standard dynamic allocation ( e.g. allocate(hostArray(N)) ) with the fclAllocHost command: Interfaces: call fclAllocHost ( cmdQ , ptr , dim ) call fclAllocHost ( ptr , dim ) cmdQ is the command queue onto which to enqueue the OpenCL map command. As usual, when cmdQ is not specified the default command queue is assumed. ptr is one of: real(sp), pointer, dimension(:) real(dp), pointer, dimension(:) integer, pointer, dimension(:) where sp and dp refer to single precision and double precision kinds respectively. Note that once allocated, ptr can be treated as any other allocatable Fortran array except that it cannot be deallocated using deallocate . dim is the number of elements for which to allocate space for. Note fclAllocHost is a blocking command: execution pauses on the host until the OpenCL map command has completed. Example: Allocate a one-dimensional float array of ten elements using pinned memory on the default command queue. real , pointer :: pinnedArray (:) ... call fclAllocHost ( pinnedArray , 10 ) API ref: fclAllocHost","title":"2.1 Allocate pinned memory"},{"location":"advanced/#22-deallocate-pinned-memory","text":"Pinned memory is implemented using pointers and is hence not automatically freed when it goes out of scope. Therefore it must be explicitly deallocated using fclFreeHost when no longer required. Interface: call fclFreeHost ( cmdq , ptr ) call fclFreeHost ( ptr ) cmdQ is the command queue onto which to enqueue the OpenCL unmap command. As usual, when cmdQ is not specified the default command queue is assumed. where ptr is any pointer allocated using fclAllocHost . Note fclFreeHost is a blocking command: execution pauses on the host until the OpenCL unmap command has completed. API ref: fclFreeHost","title":"2.2 Deallocate pinned memory"},{"location":"advanced/#3-local-kernel-arguments","text":"If a kernel has a local memory argument, then the functions fclLocalInt32 , fclLocalFloat and fclLocalDouble can be used to supply an argument with a specific dimension. Local memory arguments don't pass data to the kernel, they act like temporary variable length arrays where the size of the array can be specified at kernel launch time. Example The following OpenCL kernel has a local memory argument as the third argument: __kernel void myKernel ( const int size , __global float * vec , __local float * temp ){ int ii = get_global_id ( 0 ); int jj = get_local_id ( 0 ); temp [ jj ] = vec [ ii ] ... } To launch this kernel with Focal, we use: myKernel % launch ( nElem , deviceArray , fclLocalFloat ( localSize ) ) where localSize specifies the size of the local argument float array. API ref: fclLocalInt32 , fclLocalFloat , fclLocalDouble , fclLocalArgument ,","title":"3. Local kernel arguments"},{"location":"build/","text":"Building the Focal Library Prerequisites GNU make utility Fortran compiler supporting the 2008 standard (tested regularly with gfortran 7.4.0 & 9.1.0 and ifort 19.1.0 ) An OpenCL development library (One of: Intel OpenCL SDK , NVIDIA CUDA Toolkit , AMD Radeon Software ) Build Navigate to the repository root and run make: $> make -j Parallel build is fully supported by the makefile, so use of the -j flag is recommended. To build the example programs: $> make examples which will place example binaries in path/to/focal/bin/ . To build and run the tests: $> make -j test Build within your own project A non-recursive sub-makefile is included in the Focal repository root directory for inclusion within project makefiles. To use in your own makefile: Define the make variable FOCAL_DIR as the path to the Focal root directory Include the sub-makefile into your project makefile (after the all recipe) Create a dependency of your objects on $(FOCAL_LIB_OBJS) Add -I$(FOCAL_DIR)/mod/ to your Fortran compile flags Add -L$(FOCAL_DIR)/lib/ -lFocal -lOpenCL to your linker flags See linking for how to link against the Focal library. See this lattice Boltzmann code as an example. Example: FC ?= gfortran FOCAL_DIR = ./focal PROGS = myProgram OBJS = $( addsuffix .o, $( PROGS )) FFLAGS += -I $( FOCAL_DIR ) /mod/ LFLAGS += -L $( FOCAL_DIR ) /lib/ -lFocal -lOpenCL all : $( PROGS ) include $(FOCAL_DIR)/make.include # Objects depend on focal library $(OBJS) : $( FOCAL_LIB_OBJS ) # Recipe to link executable(s) $(PROGS) : $( OBJS ) $( FC ) $^ $( LFLAGS ) -o $@ # Recipe to compile objects %.o : %. f 90 $( FC ) $( FFLAGS ) -c $< -o $@","title":"Building the Focal Library"},{"location":"build/#building-the-focal-library","text":"","title":"Building the Focal Library"},{"location":"build/#prerequisites","text":"GNU make utility Fortran compiler supporting the 2008 standard (tested regularly with gfortran 7.4.0 & 9.1.0 and ifort 19.1.0 ) An OpenCL development library (One of: Intel OpenCL SDK , NVIDIA CUDA Toolkit , AMD Radeon Software )","title":"Prerequisites"},{"location":"build/#build","text":"Navigate to the repository root and run make: $> make -j Parallel build is fully supported by the makefile, so use of the -j flag is recommended. To build the example programs: $> make examples which will place example binaries in path/to/focal/bin/ . To build and run the tests: $> make -j test","title":"Build"},{"location":"build/#build-within-your-own-project","text":"A non-recursive sub-makefile is included in the Focal repository root directory for inclusion within project makefiles. To use in your own makefile: Define the make variable FOCAL_DIR as the path to the Focal root directory Include the sub-makefile into your project makefile (after the all recipe) Create a dependency of your objects on $(FOCAL_LIB_OBJS) Add -I$(FOCAL_DIR)/mod/ to your Fortran compile flags Add -L$(FOCAL_DIR)/lib/ -lFocal -lOpenCL to your linker flags See linking for how to link against the Focal library. See this lattice Boltzmann code as an example. Example: FC ?= gfortran FOCAL_DIR = ./focal PROGS = myProgram OBJS = $( addsuffix .o, $( PROGS )) FFLAGS += -I $( FOCAL_DIR ) /mod/ LFLAGS += -L $( FOCAL_DIR ) /lib/ -lFocal -lOpenCL all : $( PROGS ) include $(FOCAL_DIR)/make.include # Objects depend on focal library $(OBJS) : $( FOCAL_LIB_OBJS ) # Recipe to link executable(s) $(PROGS) : $( OBJS ) $( FC ) $^ $( LFLAGS ) -o $@ # Recipe to compile objects %.o : %. f 90 $( FC ) $( FFLAGS ) -c $< -o $@","title":"Build within your own project"},{"location":"contributing/","text":"Contributing Contributions from the community are welcomed via the github repositories: Code: https://github.com/LKedward/focal Documentation (this site): https://github.com/LKedward/focal-docs Ways to contribute: Verify that you can build the library on your particular architecture and that the tests run successfully. Create an issue in the source repo to report a bug or suggest a feature. Create an issue in the documentation repo to request further examples or clarification on this documentation site. Improve test code coverage and robustness by updating or creating more tests . Create a light-weight example program for the examples . Create a pull request for new features or bug fixes. Future tasks CMake build Create a quick reference card Restructure profiling output format Add more example codes","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions from the community are welcomed via the github repositories: Code: https://github.com/LKedward/focal Documentation (this site): https://github.com/LKedward/focal-docs Ways to contribute: Verify that you can build the library on your particular architecture and that the tests run successfully. Create an issue in the source repo to report a bug or suggest a feature. Create an issue in the documentation repo to request further examples or clarification on this documentation site. Improve test code coverage and robustness by updating or creating more tests . Create a light-weight example program for the examples . Create a pull request for new features or bug fixes. Future tasks CMake build Create a quick reference card Restructure profiling output format Add more example codes","title":"Contributing"},{"location":"errors/","text":"Errors There are three classes of errors to consider when writing an OpenCL application with Focal: Compile-time: errors which occur when compiling a program and which prevent a valid program from being created successfully. A compile-time error relating to a Focal library call likely indicates that you are using incompatible types ( e.g. transferring a float to an integer ). OpenCL runtime: errors which occur during an OpenCL API call. All API calls are checked by a customisable error handler. Focal runtime: errors which occur in the Focal library. These can include optional validity checks that are enabled when linking against the debug build . The remainder of this guide relates to defining a custom error handler for OpenCL API errors and using the additional runtime checks provided in the debug build. 1. OpenCL error handling An OpenCL error handler is included automatically and is called after every underlying OpenCL API call to check for errors. If an OpenCL call does not return CL_SUCCESS, then the default error handler will indicate where this occurred and will halt the program. The following blog post on streamhpc.com provides a comprehensive description of possible OpenCl error codes and is useful for debugging. If you would like to handle OpenCL errors yourself, then you can specify your own error handler. Custom error handlers must conform to the following subroutine interface: abstract interface subroutine fclErrorHandlerInterface ( errcode , focalCall , oclCall ) use iso_c_binding integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall end subroutine fclErrorHandlerInterface end interface The first argument errcode is the integer error code returned by the OpenCL API call. A utility is provided in Focal to lookup the corresponding error string fclGetErrorString(errcode) . The second argument is a character string indicating in which Focal API call the error code was produced. The third argument is a character string indicating in which OpenCL API call the error code was produced. Having written an error handling subroutine myErrorHandler conforming to the above interface, you can enact it using the global pointer fclErrorHandler at the beginning of your program: fclErrorHandler => myErrorHandler As an example, the Focal default error handler is defined by: subroutine fclDefaultErrorHandler ( errcode , focalCall , oclCall ) use iso_c_binding integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall if ( errcode /= CL_SUCCESS ) then write ( * , * ) '(!) Fatal openCl error ' , errcode , ' : ' , trim ( fclGetErrorString ( errcode )) write ( * , * ) ' at ' , focalCall , ':' , oclCall stop 1 end if end subroutine fclDefaultErrorHandler API ref: fclGetErrorString , fclHandleErrorInterface , fclDefaultErrorHandler , fclErrorHandler 2. Runtime debug checks To enable runtime debug checks, replace the link flag -lFocal with -lFocaldbg when linking your program. The following runtime checks are performed when using the debug build: Number of kernel arguments: checks that the number of arguments passed at runtime matches the actual number of arguments the OpenCL kernel accepts. Type of kernel arguments: checks that the types of arguments passed at runtime match the types that the OpenCL kernel is expecting. This includes argument address spaces. Device buffer initialisation: checks that device buffer objects are initialised when performing memory operations. Size of device buffers: checks that the size of device buffers is valid when performing memory operations such as write, read, and copy. Kernel event execution status: waits after each kernel launch and checks for error status. This is important for ensuring kernels are executing correctly. If an error code is detected, it is printed before aborting the program. Note Since each kernel launch is wait upon and status-checked in the debug build, then kernel launches become blocking operations. Kernel launches are unaffected (non-blocking) in the normal build. When a runtime error is detected the program is aborted immediately such that a stack trace is printed, and which can be used to detect the source of the error. API ref: fclDbgWait","title":"Errors"},{"location":"errors/#errors","text":"There are three classes of errors to consider when writing an OpenCL application with Focal: Compile-time: errors which occur when compiling a program and which prevent a valid program from being created successfully. A compile-time error relating to a Focal library call likely indicates that you are using incompatible types ( e.g. transferring a float to an integer ). OpenCL runtime: errors which occur during an OpenCL API call. All API calls are checked by a customisable error handler. Focal runtime: errors which occur in the Focal library. These can include optional validity checks that are enabled when linking against the debug build . The remainder of this guide relates to defining a custom error handler for OpenCL API errors and using the additional runtime checks provided in the debug build.","title":"Errors"},{"location":"errors/#1-opencl-error-handling","text":"An OpenCL error handler is included automatically and is called after every underlying OpenCL API call to check for errors. If an OpenCL call does not return CL_SUCCESS, then the default error handler will indicate where this occurred and will halt the program. The following blog post on streamhpc.com provides a comprehensive description of possible OpenCl error codes and is useful for debugging. If you would like to handle OpenCL errors yourself, then you can specify your own error handler. Custom error handlers must conform to the following subroutine interface: abstract interface subroutine fclErrorHandlerInterface ( errcode , focalCall , oclCall ) use iso_c_binding integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall end subroutine fclErrorHandlerInterface end interface The first argument errcode is the integer error code returned by the OpenCL API call. A utility is provided in Focal to lookup the corresponding error string fclGetErrorString(errcode) . The second argument is a character string indicating in which Focal API call the error code was produced. The third argument is a character string indicating in which OpenCL API call the error code was produced. Having written an error handling subroutine myErrorHandler conforming to the above interface, you can enact it using the global pointer fclErrorHandler at the beginning of your program: fclErrorHandler => myErrorHandler As an example, the Focal default error handler is defined by: subroutine fclDefaultErrorHandler ( errcode , focalCall , oclCall ) use iso_c_binding integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall if ( errcode /= CL_SUCCESS ) then write ( * , * ) '(!) Fatal openCl error ' , errcode , ' : ' , trim ( fclGetErrorString ( errcode )) write ( * , * ) ' at ' , focalCall , ':' , oclCall stop 1 end if end subroutine fclDefaultErrorHandler API ref: fclGetErrorString , fclHandleErrorInterface , fclDefaultErrorHandler , fclErrorHandler","title":"1. OpenCL error handling"},{"location":"errors/#2-runtime-debug-checks","text":"To enable runtime debug checks, replace the link flag -lFocal with -lFocaldbg when linking your program. The following runtime checks are performed when using the debug build: Number of kernel arguments: checks that the number of arguments passed at runtime matches the actual number of arguments the OpenCL kernel accepts. Type of kernel arguments: checks that the types of arguments passed at runtime match the types that the OpenCL kernel is expecting. This includes argument address spaces. Device buffer initialisation: checks that device buffer objects are initialised when performing memory operations. Size of device buffers: checks that the size of device buffers is valid when performing memory operations such as write, read, and copy. Kernel event execution status: waits after each kernel launch and checks for error status. This is important for ensuring kernels are executing correctly. If an error code is detected, it is printed before aborting the program. Note Since each kernel launch is wait upon and status-checked in the debug build, then kernel launches become blocking operations. Kernel launches are unaffected (non-blocking) in the normal build. When a runtime error is detected the program is aborted immediately such that a stack trace is printed, and which can be used to detect the source of the error. API ref: fclDbgWait","title":"2. Runtime debug checks"},{"location":"events/","text":"Events and synchronisation Most OpenCL commands involve enqueueing an operation to a command queue and returning control back to the host program. If an in-order command queue is used then these operations are guaranteed to be executed in the order that they were submitted. Implicit host-device synchronisations can occur if blocking data transfers are used (see host-device transfers ). To explicitly keep track of enqueued operations on the host, we can use event objects issued with each command. If an out-of-order command queue is used, then additional consideration must be made for inter-dependencies between the operations enqueued; this is enabled by command queue barriers and dependencies. 1. Event objects Event objects represent operations that have been submitted to a command queue and provide a way of keeping track and specifying dependencies. The following event objects are made available following certain enqueing operations: Action Event Object Action Example Transfer host array to device buffer fclLastWriteEvent , cmdq%lastWriteEvent deviceArray = hostArray Transfer device buffer to host array fclLastReadEvent cmdq%lastReadEvent hostArray = deviceArray Copy device buffer to device buffer fclLastCopyEvent cmdq%lastCopyEvent deviceArray2 = deviceArray1 Launch kernel fclLastKernelEvent cmdq%lastKernelEvent myKernel%launch() Enqueue queue barrier fclLastBarrierEvent cmdq%lastBarrierEvent call fclBarrier(...) API ref: fclCommandQ , fclLastWriteEvent, fclLastReadEvent, fclLastCopyEvent, fclLastKernelEvent, fclLastBarrierEvent 2. Host synchronisation 2.1 Waiting for events To wait on the host for device events to complete, use the fclWait command. This command has multiple interfaces defined below. Interfaces call fclWait () call fclWait ( < fclCommandQ > ) call fclWait ( < fclEvent > ) call fclWait ( < fclEvent ( n ) > ) When called without any arguments fclWait will wait for all events on the default command queue to finish. Alternatively, a specific command queue may be specified by passing it as an argument to fclWait . To wait for a specific event to finish, pass that event to fclWait . Alternatively, to wait for multiple events to complete, pass an array of fclEvent objects to fclWait . Example: Wait on a specific command queue. type ( fclCommandQ ) :: myCommandQ ... call fclWait ( myCommandQ ) Example: Wait for a kernel event to complete. type ( fclKernel ) :: myKernel type ( fclEvent ) :: e ... myKernel % launch () ! Launch kernel e = fclLastKernelEvent ! Save kernel event object ... ! Perform other operations call fclWait ( e ) ! Now wait for kernel to complete Example: Enqueue multiple asynchronous data transfers. type ( fclCommandQ ) :: cmdq type ( fclDeviceFloat ) :: a1 , a2 , a3 type ( fclEvent ), dimension ( 3 ) :: e ... cmdq % blockingWrite = . false . ! Enable asynchronous host-to-device transfers ... a1 = hostArray1 ! Enqueue first transfer e ( 1 ) = cmdq % lastWriteEvent ! Save first transfer event a2 = hostArray2 ! Enqueue second transfer e ( 2 ) = cmdq % lastWriteEvent ! Save second transfer event a3 = hostArray3 ! Enqueue third transfer e ( 3 ) = cmdq % lastWriteEvent ! Save third transfer event ... ! Perform other operations call fclWait ( e ) ! Now wait for transfers to complete API ref: fclWait 3. Dependencies and barriers If using a single command queue with out-of-order execution disabled, then commands are guaranteed to be executed in the order that they were enqueued. When using multiple command queues to submit work, or when using command queues with out-of-order execution enabled, then explicit management of dependencies is required to ensure that work is performed in the correct order; two useful mechanisms are available for this: barriers and event dependencies. 3.1 Event dependencies Event dependencies are set prior to enqueueing an operation to specify operations that must first complete for the following operation to start. The Focal command fclSetDependency is used to specify dependencies for the next enqueued operation. Example: A kernel event depends on previous data transfers type ( fclDeviceFloat ) :: deviceArray1 , deviceArray2 type ( fclKernel ) :: myKernel1 , myKernel2 type ( fclEvent ) :: e ( 2 ) type ( fclCommandQ ) :: cmdq2 ... call fclSetDefaultCommandQ ( fclCreateCommandQ ( devices ( 1 ), blockingWrite = . false .) ) cmdq2 = fclCreateCommandQ ( devices ( 1 )) deviceArray1 = hostArray e ( 1 ) = fclLastWriteEvent ! Save first write event deviceArray2 = hostArray e ( 2 ) = fclLastWriteEvent ! Save second write event ... ! Launch kernel with no dependencies on separate cmdq myKernel1 % launch ( cmdq2 ) ... ! Launch kernel with dependency on events in e call fclSetDependency ( e ) myKernel2 % launch ( deviceArray1 , deviceArray2 ) In this example several host-to-device transfers are enqueued followed immediately by an independent kernel execution; this first kernel can theoretically be executed at the same time as the transfers are occuring. A second kernel is enqueued with explicit dependencies on the previous transfers; this kernel won't execute until the transfers are complete. Note Unless hold=.true. is specified in fclSetDependency then, dependencies are cleared after each enqueued operations. i.e. event dependencies will only apply to the next enqueued operation not to subsequent ones. See example below for multiple events sharing the same dependency. Example: Apply the same event dependencies to multiple subsequent commands type ( fclKernel ) :: myKernel type ( fclEvent ) :: e ... myKernel % launch () e = fclLastKernelEvent ... call fclSetDependency ( e , hold = . true .) ! Data transfers all depend on previous kernel launch hostData1 = deviceData1 hostData2 = deviceData2 hostData3 = deviceData3 call fclClearDependencies () ! Clear held dependencies API ref: fclSetDependency , fclClearDependencies 3.2 Command queue barriers OpenCL barriers break up the command queue into regions between which there can be no re-ordering of operations. If a series of operations (group A) is followed by a barrier then followed by another series of operations (group A), then all events from group a must be complete (in any order) before any event in group B can start. To enqueue a barrier in Focal, use fclBarrier : Interfaces call fclBarrier () call fclBarrier ( < fclCommandQ > ) When called with no arguments, this enqueues a barrier onto the default command queue . Otherwise, it enqueues a barrier onto the command queue specified in the first argument. The barrier can be waiting upon or set as a dependency using the event objects: fclLastBarrierEvent or cmdq%lastBarrierEvent ; this is useful in referencing groups of events. Example: Wait on a group of asynchronous transfers to complete type ( fclCommandQ ) :: cmdq type ( fclDeviceFloat ) :: a , b , c ... cmdq = fclCreateCommandQ ( devices ( 1 ), blockingWrite = . false .) ... ! Enqueue asynchronous transfers to device a = hostA b = hostB c = hostC ! Enqueue barrier call fclBarrier ( cmdq ) ... ! Wait for all transfers to complete call fclWait ( cmdq % lastBarrierEvent ) ... ! OR set a dependency for all transfers to complete call fclSetDependency ( cmdq % fclLastBarrierEvent ) ... API ref: fclBarrier , fclWait , fclSetDependency , fclCommandQ , fclLastBarrierEvent 3.3 User events OpenCL user events provide a way for device operations to wait for the completion of host operations. A user event is first created which can be used as a dependency for subsequently enqued device operations. The host program can then trigger the user event to signal its completion and allow it dependents to start executing. Example: type ( fclEvent ) :: myHostEvent type ( fclKernel ) :: myKernel ... ! Create user event myHostEvent = fclCreateUserEvent () ! Set dependency on user event call fclSetDependency ( myHostEvent ) call myKernel % launch () ... ! Do some other work ! Trigger user event to signal completion call fclSetUserEvent ( myHostEvent ) ! Kernel will now run API ref: fclCreateUserEvent , fclSetUserEvent","title":"Events and synchronisation"},{"location":"events/#events-and-synchronisation","text":"Most OpenCL commands involve enqueueing an operation to a command queue and returning control back to the host program. If an in-order command queue is used then these operations are guaranteed to be executed in the order that they were submitted. Implicit host-device synchronisations can occur if blocking data transfers are used (see host-device transfers ). To explicitly keep track of enqueued operations on the host, we can use event objects issued with each command. If an out-of-order command queue is used, then additional consideration must be made for inter-dependencies between the operations enqueued; this is enabled by command queue barriers and dependencies.","title":"Events and synchronisation"},{"location":"events/#1-event-objects","text":"Event objects represent operations that have been submitted to a command queue and provide a way of keeping track and specifying dependencies. The following event objects are made available following certain enqueing operations: Action Event Object Action Example Transfer host array to device buffer fclLastWriteEvent , cmdq%lastWriteEvent deviceArray = hostArray Transfer device buffer to host array fclLastReadEvent cmdq%lastReadEvent hostArray = deviceArray Copy device buffer to device buffer fclLastCopyEvent cmdq%lastCopyEvent deviceArray2 = deviceArray1 Launch kernel fclLastKernelEvent cmdq%lastKernelEvent myKernel%launch() Enqueue queue barrier fclLastBarrierEvent cmdq%lastBarrierEvent call fclBarrier(...) API ref: fclCommandQ , fclLastWriteEvent, fclLastReadEvent, fclLastCopyEvent, fclLastKernelEvent, fclLastBarrierEvent","title":"1. Event objects"},{"location":"events/#2-host-synchronisation","text":"","title":"2. Host synchronisation"},{"location":"events/#21-waiting-for-events","text":"To wait on the host for device events to complete, use the fclWait command. This command has multiple interfaces defined below. Interfaces call fclWait () call fclWait ( < fclCommandQ > ) call fclWait ( < fclEvent > ) call fclWait ( < fclEvent ( n ) > ) When called without any arguments fclWait will wait for all events on the default command queue to finish. Alternatively, a specific command queue may be specified by passing it as an argument to fclWait . To wait for a specific event to finish, pass that event to fclWait . Alternatively, to wait for multiple events to complete, pass an array of fclEvent objects to fclWait . Example: Wait on a specific command queue. type ( fclCommandQ ) :: myCommandQ ... call fclWait ( myCommandQ ) Example: Wait for a kernel event to complete. type ( fclKernel ) :: myKernel type ( fclEvent ) :: e ... myKernel % launch () ! Launch kernel e = fclLastKernelEvent ! Save kernel event object ... ! Perform other operations call fclWait ( e ) ! Now wait for kernel to complete Example: Enqueue multiple asynchronous data transfers. type ( fclCommandQ ) :: cmdq type ( fclDeviceFloat ) :: a1 , a2 , a3 type ( fclEvent ), dimension ( 3 ) :: e ... cmdq % blockingWrite = . false . ! Enable asynchronous host-to-device transfers ... a1 = hostArray1 ! Enqueue first transfer e ( 1 ) = cmdq % lastWriteEvent ! Save first transfer event a2 = hostArray2 ! Enqueue second transfer e ( 2 ) = cmdq % lastWriteEvent ! Save second transfer event a3 = hostArray3 ! Enqueue third transfer e ( 3 ) = cmdq % lastWriteEvent ! Save third transfer event ... ! Perform other operations call fclWait ( e ) ! Now wait for transfers to complete API ref: fclWait","title":"2.1 Waiting for events"},{"location":"events/#3-dependencies-and-barriers","text":"If using a single command queue with out-of-order execution disabled, then commands are guaranteed to be executed in the order that they were enqueued. When using multiple command queues to submit work, or when using command queues with out-of-order execution enabled, then explicit management of dependencies is required to ensure that work is performed in the correct order; two useful mechanisms are available for this: barriers and event dependencies.","title":"3. Dependencies and barriers"},{"location":"events/#31-event-dependencies","text":"Event dependencies are set prior to enqueueing an operation to specify operations that must first complete for the following operation to start. The Focal command fclSetDependency is used to specify dependencies for the next enqueued operation. Example: A kernel event depends on previous data transfers type ( fclDeviceFloat ) :: deviceArray1 , deviceArray2 type ( fclKernel ) :: myKernel1 , myKernel2 type ( fclEvent ) :: e ( 2 ) type ( fclCommandQ ) :: cmdq2 ... call fclSetDefaultCommandQ ( fclCreateCommandQ ( devices ( 1 ), blockingWrite = . false .) ) cmdq2 = fclCreateCommandQ ( devices ( 1 )) deviceArray1 = hostArray e ( 1 ) = fclLastWriteEvent ! Save first write event deviceArray2 = hostArray e ( 2 ) = fclLastWriteEvent ! Save second write event ... ! Launch kernel with no dependencies on separate cmdq myKernel1 % launch ( cmdq2 ) ... ! Launch kernel with dependency on events in e call fclSetDependency ( e ) myKernel2 % launch ( deviceArray1 , deviceArray2 ) In this example several host-to-device transfers are enqueued followed immediately by an independent kernel execution; this first kernel can theoretically be executed at the same time as the transfers are occuring. A second kernel is enqueued with explicit dependencies on the previous transfers; this kernel won't execute until the transfers are complete. Note Unless hold=.true. is specified in fclSetDependency then, dependencies are cleared after each enqueued operations. i.e. event dependencies will only apply to the next enqueued operation not to subsequent ones. See example below for multiple events sharing the same dependency. Example: Apply the same event dependencies to multiple subsequent commands type ( fclKernel ) :: myKernel type ( fclEvent ) :: e ... myKernel % launch () e = fclLastKernelEvent ... call fclSetDependency ( e , hold = . true .) ! Data transfers all depend on previous kernel launch hostData1 = deviceData1 hostData2 = deviceData2 hostData3 = deviceData3 call fclClearDependencies () ! Clear held dependencies API ref: fclSetDependency , fclClearDependencies","title":"3.1 Event dependencies"},{"location":"events/#32-command-queue-barriers","text":"OpenCL barriers break up the command queue into regions between which there can be no re-ordering of operations. If a series of operations (group A) is followed by a barrier then followed by another series of operations (group A), then all events from group a must be complete (in any order) before any event in group B can start. To enqueue a barrier in Focal, use fclBarrier : Interfaces call fclBarrier () call fclBarrier ( < fclCommandQ > ) When called with no arguments, this enqueues a barrier onto the default command queue . Otherwise, it enqueues a barrier onto the command queue specified in the first argument. The barrier can be waiting upon or set as a dependency using the event objects: fclLastBarrierEvent or cmdq%lastBarrierEvent ; this is useful in referencing groups of events. Example: Wait on a group of asynchronous transfers to complete type ( fclCommandQ ) :: cmdq type ( fclDeviceFloat ) :: a , b , c ... cmdq = fclCreateCommandQ ( devices ( 1 ), blockingWrite = . false .) ... ! Enqueue asynchronous transfers to device a = hostA b = hostB c = hostC ! Enqueue barrier call fclBarrier ( cmdq ) ... ! Wait for all transfers to complete call fclWait ( cmdq % lastBarrierEvent ) ... ! OR set a dependency for all transfers to complete call fclSetDependency ( cmdq % fclLastBarrierEvent ) ... API ref: fclBarrier , fclWait , fclSetDependency , fclCommandQ , fclLastBarrierEvent","title":"3.2 Command queue barriers"},{"location":"events/#33-user-events","text":"OpenCL user events provide a way for device operations to wait for the completion of host operations. A user event is first created which can be used as a dependency for subsequently enqued device operations. The host program can then trigger the user event to signal its completion and allow it dependents to start executing. Example: type ( fclEvent ) :: myHostEvent type ( fclKernel ) :: myKernel ... ! Create user event myHostEvent = fclCreateUserEvent () ! Set dependency on user event call fclSetDependency ( myHostEvent ) call myKernel % launch () ... ! Do some other work ! Trigger user event to signal completion call fclSetUserEvent ( myHostEvent ) ! Kernel will now run API ref: fclCreateUserEvent , fclSetUserEvent","title":"3.3 User events"},{"location":"kernels/","text":"Working with kernels See setup and memory first for how to setup contexts, command queues and manage device memory. See also in advanced topics : Local kernel arguments 1. Loading kernel sources OpenCL kernels are almost always shipped as plain text sources which are compiled at runtime for the required architecture; this allows perfect portability of programs using OpenCL kernels. Focal provides two utility routines for obtaining OpenCL kernel source code at runtime: fclSourceFromFile which loads source code from a file path fclGetKernelResource which loads source code that was linked at compile time as a binary resource. Loading source using fclSourceFromFile from allows kernel sources to be updated without recompilation however it relies on robustly being able to locate kernel source files at runtime. Linking source code as a binary resource allows kernel sources to be included into the program executable and therefore doesn't require source files to be distributed in addition to the OpenCL program. 1.1 From file Use fclSourceFromFile to load source code from a file at runtime. Example character (:), allocatable :: programSource ... call fclSourceFromFile ( filename = 'programKernels.cl' , programSource ) In this example, kernel source code is read from the file programKernels.cl into the character string programSource which is allocated during the call. API ref: fclSourceFromFile 1.2 From linked binary resource Step 1: Create object file from kernel code. At the command line we use the linker ld to convert the kernel text file fclKernels.cl into a binary resource object: $> ld -r -b binary fclKernels.cl -o fclKernels.o In the call to ld the output binary file can have any arbitrary name, however the input file, containing the kernels source text, MUST be called fclKernels.cl with no path prefix . Step 2: Compile and link the main program with the fclKernels.o resource object: $> gfortran -c myCLProgram.f90 -o myCLProgram.o $> gfortran myCLProgram.o fclKernels.o -lfocal -lOpenCL -o myCLProgram Step 3: Load the linked kernel source at runtime using fclGetKernelResource character (:), allocatable :: programSource ... call fclGetKernelResource ( programSource ) See the examples makefile in the repository for how this can be done during the build process. API ref: fclGetKernelResource 2. Compiling kernels Once kernel source code has been loaded into a character string ( character(len=n) ), the code can be compiled using fclCompileProgram . An OpenCL 'program' simply refers to a collection of kernels. So we can collect all our kernels into a single character string and compile them together. Interfaces prog = fclCompileProgram ([ ctx ], source ,[ options ]) * prog ( type(fclProgram) ): compiled program object ctx ( type(fclContext) , optional ): context on which to compile program. Default context is used if omitted. source ( character(*) ): the OpenCL program source code to compile options ( character(*) , optional ): specifies OpenCL compilation options . Once compiled, a specific Focal kernel object can be extracted from the compiled program object using fclGetProgramKernel . This returns an fclKernel object which we can use to launch a specific kernel. Interfaces kern = fclGetProgramKernel ( prog , kernelName ,[ global_work_size ],[ local_work_size ], & [ work_dim ],[ global_work_offset ]) kern ( type(fclKernel) ): kernel object used to launch kernels prog ( type(fclProgram) ): program object containing compiled kernels kernelName ( character(*) ): case-sensitive kernel function name global_work_size ( integer(dim) , optional ) array (up to length 3) specifying global work dimensions. Default unset. If specified, also automatically sets work_dim to the length of global_work_size . local_work_size ( integer(dim) , optional ) array (up to length 3) specifying local work group dimensions. Default [0,0,0] meaning OpenCL sets the local work dimensions. work_dim ( integer , optional ) specifies number of work group dimensions. Default 1 or length of global_work_size if specified. global_work_offset ( integer(dim) , optional ) array specifying global work offsets in each dimension, default [0,0,0] The kernel parameters global_work_size , local_work_size , work_dim , and global_work_offset can also be set using the syntax: kern % global_work_size = [ 10 , 10 , 10 ] kern % local_work_size = [ 10 , 1 , 1 ] kern % work_dim = 3 kern % global_work_offset = [ 0 , 0 , 0 ] Warning When kernels are launched, the global_work_size is automatically modified to ensure it is a multiple of local_work_size in all dimensions by increasing it where necessary - make sure to guard against out-of-bounds thread indexes within your kernels. Example type ( fclProgram ) :: program type ( fclKernel ) :: myKernel ... program = fclCompileProgram ( myProgramSource ) myKernel = fclGetProgramKernel ( program , 'myKernel' ) API ref: fclCompileProgram , fclGetProgramKernel , fclProgram , fclKernel 3. Launching kernels Once an fclKernel object exists, the kernel can be launched with the following syntax: myKernel % launch ( cmdq , arg1 , arg2 ) or equivalently: call fclLaunchKernel ( myKernel , cmdq , arg1 , arg2 ) If the default command queue has been set, then cmdq can be omitted here. In these examples two kernel arguments are supplied arg1 and arg2 . Kernel arguments can be scalar variables, device buffer objects or local memory specifiers. Up to 20 kernel arguments can be specified using this syntax. Example: Launch a kernel with a scalar integer argument and a device buffer argument. integer :: nElem = 1000 type ( fclDeviceInt32 ) :: deviceArray ... deviceArray = fclBufferInt32 ( dim = nElem , read = . true ., write = . true .) myKernel % launch ( nElem , deviceArray ) Note OpenCL kernel arguments persist between calls, therefore subsequent kernel launch calls can omit arguments if unchanged. Use fclSetKernelArg and fclSetKernelArgs to change a single/multiple kernel argument(s) between kernel launches. API ref: fclKernel , fclLaunchKernel , fclLaunchKernelAfter fclSetKernelArg , fclSetKernelArgs","title":"Working with kernels"},{"location":"kernels/#working-with-kernels","text":"See setup and memory first for how to setup contexts, command queues and manage device memory. See also in advanced topics : Local kernel arguments","title":"Working with kernels"},{"location":"kernels/#1-loading-kernel-sources","text":"OpenCL kernels are almost always shipped as plain text sources which are compiled at runtime for the required architecture; this allows perfect portability of programs using OpenCL kernels. Focal provides two utility routines for obtaining OpenCL kernel source code at runtime: fclSourceFromFile which loads source code from a file path fclGetKernelResource which loads source code that was linked at compile time as a binary resource. Loading source using fclSourceFromFile from allows kernel sources to be updated without recompilation however it relies on robustly being able to locate kernel source files at runtime. Linking source code as a binary resource allows kernel sources to be included into the program executable and therefore doesn't require source files to be distributed in addition to the OpenCL program.","title":"1. Loading kernel sources"},{"location":"kernels/#11-from-file","text":"Use fclSourceFromFile to load source code from a file at runtime. Example character (:), allocatable :: programSource ... call fclSourceFromFile ( filename = 'programKernels.cl' , programSource ) In this example, kernel source code is read from the file programKernels.cl into the character string programSource which is allocated during the call. API ref: fclSourceFromFile","title":"1.1 From file"},{"location":"kernels/#12-from-linked-binary-resource","text":"Step 1: Create object file from kernel code. At the command line we use the linker ld to convert the kernel text file fclKernels.cl into a binary resource object: $> ld -r -b binary fclKernels.cl -o fclKernels.o In the call to ld the output binary file can have any arbitrary name, however the input file, containing the kernels source text, MUST be called fclKernels.cl with no path prefix . Step 2: Compile and link the main program with the fclKernels.o resource object: $> gfortran -c myCLProgram.f90 -o myCLProgram.o $> gfortran myCLProgram.o fclKernels.o -lfocal -lOpenCL -o myCLProgram Step 3: Load the linked kernel source at runtime using fclGetKernelResource character (:), allocatable :: programSource ... call fclGetKernelResource ( programSource ) See the examples makefile in the repository for how this can be done during the build process. API ref: fclGetKernelResource","title":"1.2 From linked binary resource"},{"location":"kernels/#2-compiling-kernels","text":"Once kernel source code has been loaded into a character string ( character(len=n) ), the code can be compiled using fclCompileProgram . An OpenCL 'program' simply refers to a collection of kernels. So we can collect all our kernels into a single character string and compile them together. Interfaces prog = fclCompileProgram ([ ctx ], source ,[ options ]) * prog ( type(fclProgram) ): compiled program object ctx ( type(fclContext) , optional ): context on which to compile program. Default context is used if omitted. source ( character(*) ): the OpenCL program source code to compile options ( character(*) , optional ): specifies OpenCL compilation options . Once compiled, a specific Focal kernel object can be extracted from the compiled program object using fclGetProgramKernel . This returns an fclKernel object which we can use to launch a specific kernel. Interfaces kern = fclGetProgramKernel ( prog , kernelName ,[ global_work_size ],[ local_work_size ], & [ work_dim ],[ global_work_offset ]) kern ( type(fclKernel) ): kernel object used to launch kernels prog ( type(fclProgram) ): program object containing compiled kernels kernelName ( character(*) ): case-sensitive kernel function name global_work_size ( integer(dim) , optional ) array (up to length 3) specifying global work dimensions. Default unset. If specified, also automatically sets work_dim to the length of global_work_size . local_work_size ( integer(dim) , optional ) array (up to length 3) specifying local work group dimensions. Default [0,0,0] meaning OpenCL sets the local work dimensions. work_dim ( integer , optional ) specifies number of work group dimensions. Default 1 or length of global_work_size if specified. global_work_offset ( integer(dim) , optional ) array specifying global work offsets in each dimension, default [0,0,0] The kernel parameters global_work_size , local_work_size , work_dim , and global_work_offset can also be set using the syntax: kern % global_work_size = [ 10 , 10 , 10 ] kern % local_work_size = [ 10 , 1 , 1 ] kern % work_dim = 3 kern % global_work_offset = [ 0 , 0 , 0 ] Warning When kernels are launched, the global_work_size is automatically modified to ensure it is a multiple of local_work_size in all dimensions by increasing it where necessary - make sure to guard against out-of-bounds thread indexes within your kernels. Example type ( fclProgram ) :: program type ( fclKernel ) :: myKernel ... program = fclCompileProgram ( myProgramSource ) myKernel = fclGetProgramKernel ( program , 'myKernel' ) API ref: fclCompileProgram , fclGetProgramKernel , fclProgram , fclKernel","title":"2. Compiling kernels"},{"location":"kernels/#3-launching-kernels","text":"Once an fclKernel object exists, the kernel can be launched with the following syntax: myKernel % launch ( cmdq , arg1 , arg2 ) or equivalently: call fclLaunchKernel ( myKernel , cmdq , arg1 , arg2 ) If the default command queue has been set, then cmdq can be omitted here. In these examples two kernel arguments are supplied arg1 and arg2 . Kernel arguments can be scalar variables, device buffer objects or local memory specifiers. Up to 20 kernel arguments can be specified using this syntax. Example: Launch a kernel with a scalar integer argument and a device buffer argument. integer :: nElem = 1000 type ( fclDeviceInt32 ) :: deviceArray ... deviceArray = fclBufferInt32 ( dim = nElem , read = . true ., write = . true .) myKernel % launch ( nElem , deviceArray ) Note OpenCL kernel arguments persist between calls, therefore subsequent kernel launch calls can omit arguments if unchanged. Use fclSetKernelArg and fclSetKernelArgs to change a single/multiple kernel argument(s) between kernel launches. API ref: fclKernel , fclLaunchKernel , fclLaunchKernelAfter fclSetKernelArg , fclSetKernelArgs","title":"3. Launching kernels"},{"location":"linking/","text":"Linking Focal Programs Include To use the Focal module in your own code, include the module with the use syntax: program myprogram use Focal implicit none ... end program myprogram Compile To compile a program using the Focal module, you must point the compiler to the mod/Focal.mod definition in the Focal repository. For example, in gfortran this is done with the -I flag: $> gfortran -c myprogram.f90 -I/path/to/focal/mod/ -o myprogram.o Link To link, you need to specify the path to the Focal repository and directives for Focal and OpenCL : $> gfortran myprogram.o -L/path/to/focal/lib/ -lFocal -lOpenCL -o bin/myprogram See examples in the repository for how this can be done with a makefile . Debug build When the Focal library is built, two versions are produced: libFocal and libFocaldbg where the latter contains additional runtime calls that check the validity of your program. To link against the debug build replace -lFocal with -lFocaldbg in the linking command. See here for more information on runtime debug checks.","title":"Linking Focal Programs"},{"location":"linking/#linking-focal-programs","text":"","title":"Linking Focal Programs"},{"location":"linking/#include","text":"To use the Focal module in your own code, include the module with the use syntax: program myprogram use Focal implicit none ... end program myprogram","title":"Include"},{"location":"linking/#compile","text":"To compile a program using the Focal module, you must point the compiler to the mod/Focal.mod definition in the Focal repository. For example, in gfortran this is done with the -I flag: $> gfortran -c myprogram.f90 -I/path/to/focal/mod/ -o myprogram.o","title":"Compile"},{"location":"linking/#link","text":"To link, you need to specify the path to the Focal repository and directives for Focal and OpenCL : $> gfortran myprogram.o -L/path/to/focal/lib/ -lFocal -lOpenCL -o bin/myprogram See examples in the repository for how this can be done with a makefile .","title":"Link"},{"location":"linking/#debug-build","text":"When the Focal library is built, two versions are produced: libFocal and libFocaldbg where the latter contains additional runtime calls that check the validity of your program. To link against the debug build replace -lFocal with -lFocaldbg in the linking command. See here for more information on runtime debug checks.","title":"Debug build"},{"location":"memory/","text":"Managing memory See setup first for how to define a context and create a device command queue. See also in advanced topics : Sub-buffers Pinned host memory 1. Initialise device memory Initialisation of device memory requires a dimension (number of elements) and logicaleans indicating the read/write access of kernels. A command queue may optionally be specified, if omitted the the default command queue is used ( fclDefaultCommandQ ). Interfaces call fclInitBuffer ([ cmdQ ], untypedBuffer , nBytes ,[ profileName ],[ access ]) call fclInitBuffer ([ cmdQ ], typedBuffer , dim ,[ profileName ],[ access ]) cmdQ ( optional ) specifies the command queue to which this buffer is associated. All buffer operations will occur on this command queue. cmdQ can be omitted if the default command queue has been set. untypedBuffer ( type(fclDeviceBuffer) ) is a general buffer object with no associated type information. typedBuffer can be one of type(fclDeviceInt32) , type(fclDeviceFloat) , type(fclDeviceDouble) . nBytes ( integer ): number of bytes to allocated for an untyped buffer object. dim ( integer ): number of elements for which to allocate the typed buffer. profileName ( character(*) , optional ): descriptive name for printing profiling information. See profiling . access (one of 'r' , 'w' , 'rw' , optional ): kernel read/write access to buffer, default 'rw' . Note All buffer operations are submitted to the command queue specified at buffer initialisation. To change the command queue associated with a buffer use the syntax: buffer%cmdq => newCmdQ . Example: read-only integer buffer with 1000 elements type ( fclDeviceInt32 ) :: array_d call fclInitBuffer ( array_d , dim = 1000 , access = 'r' ) No command queue is specified, so the default command queue is used ( fclDefaultCmdQ ) which is assumed to have been initialised. 'Read only' in this context means that OpenCL kernels cannot write to this buffer. Example: read-write double precision buffer with command queue type ( fclDeviceDouble ) :: array_d type ( fclCmdQ ) :: cmdq ... call fclInitBuffer ( cmdq , array_d , dim = 1000 , profileName = 'array_d' ) API ref: fclInitBuffer , fclDeviceBuffer , fclDeviceInt32 , fclDeviceFloat , fclDeviceDouble 2. Fill device buffer with scalar The assignment = operator can be used to fill an initialised device buffer with a scalar value. Example type ( fclDeviceFloat ) :: deviceFloat type ( fclDevicDouble ) :: deviceDouble ... ! Initialise device arrays call fclInitBuffer ( deviceFloat , Nelem ) call fclInitBuffer ( deviceDouble , Nelem ) ! Fill arrays with zeros deviceFloat = 0.0 deviceDouble = 0.0d0 Note Since filling an array with a scalar value does not involve a host array pointer, it is non-blocking . The scalar assignment is enqueued onto the command queue and host code continues. Call fclWait(cmdq%lastWriteEvent) to wait. API ref: Assignment(=) 3. Data transfer between device and host Data transfer between a device buffer and a host array can be achieved using the assignment = operation. When transferring data, the host and device arrays must be of compatible types. Example : transfer from host to device real ( real32 ) :: hostArray ( Nelem ) type ( fclDeviceFloat ) :: deviceArray ... ! Initialise device array call fclInitBuffer ( deviceArray , Nelem ) ! Copy to device from host deviceArray = hostArray Note Since transferring arrays involves a host array pointer, it is blocking by default. Host code does not continue until transfer completes. Set command queue blockingWrite and blockingRead to .false. for asynchronous transfers. Example: Non-blocking data transfer To perform non-blocking transfer, we set the command queue parameter variables blockingWrite and blockingRead to .false. as required. To keep track of the transfer operations we can use the command queue variables lastWriteEvent and lastReadEvent or the global variables fclLastWriteEvent and fclLastReadEvent . type ( fclEvent ) :: e ... cmdq % blockingWrite = . false . ! Enable non-blocking host-to-device transfers deviceArray = hostArray ! Enqueue the transfer command e = cmdq % lastWriteEvent ! Get transfer event object ... call fclWait ( e ) ! Wait for event when needed If using the default command queue then replace cmdq with fclDefaultCmdQ . API ref: Assignment(=) , fclCommandQ , fclWait 4. Transfer device array to device array Device arrays and device array pointers can also be copied using the assignment = operator. If both the source object (right value) and target object (left value) are valid initialised device array objects, then the assignment operation will enqueue a non-blocking device-to-device transfer. This event can be waited upon by the host using fclWait(cmdq%lastCopyEvent) . If the target object (left value) is not initialised then the assignment operation will copy the pointer from the initialised source object (right value) such that both objects refer to the same device array. If the source object (right value) is not initialised then the assignment operation is invalid and will result in a runtime error. Example type ( fclDeviceInt32 ) :: deviceArray1 type ( fclDeviceInt32 ) :: deviceArray2 ... ! Initialise device array 1 call fclInitBuffer ( deviceArray1 , Nelem ) deviceArray2 = deviceArray1 ! deviceArray2 and deviceArray1 now reference the same device buffer Example type ( fclDeviceInt32 ) :: deviceArray1 type ( fclDeviceInt32 ) :: deviceArray2 ... ! Initialise both device arrays call fclInitBuffer ( deviceArray1 , Nelem ) call fclInitBuffer ( deviceArray2 , Nelem ) ... deviceArray2 = deviceArray1 call fclWait ( fclLastCopyEvent ) ! Contents of deviceArray1 copied to deviceArray2 API ref: Assignment(=) , fclCommandQ , fclWait 5. Swap buffer pointers Device buffer pointers can be swapped on the host using fclBufferSwap . This can be more efficient than performing a device-to-device copy. Example integer :: i type ( fclKernel ) :: myKernel type ( fclDeviceFloat ) :: a1_d , a2_d ... do i = 1 , 10 call myKernel % launch ( a1_d ) ... call fclBufferSwap ( a1_d , a2_d ) end do 6. Free device memory Device memory is released using fclFreeBuffer . Example call fclFreeBuffer ( deviceArray ) API ref: fclFreeBuffer","title":"Managing memory"},{"location":"memory/#managing-memory","text":"See setup first for how to define a context and create a device command queue. See also in advanced topics : Sub-buffers Pinned host memory","title":"Managing memory"},{"location":"memory/#1-initialise-device-memory","text":"Initialisation of device memory requires a dimension (number of elements) and logicaleans indicating the read/write access of kernels. A command queue may optionally be specified, if omitted the the default command queue is used ( fclDefaultCommandQ ). Interfaces call fclInitBuffer ([ cmdQ ], untypedBuffer , nBytes ,[ profileName ],[ access ]) call fclInitBuffer ([ cmdQ ], typedBuffer , dim ,[ profileName ],[ access ]) cmdQ ( optional ) specifies the command queue to which this buffer is associated. All buffer operations will occur on this command queue. cmdQ can be omitted if the default command queue has been set. untypedBuffer ( type(fclDeviceBuffer) ) is a general buffer object with no associated type information. typedBuffer can be one of type(fclDeviceInt32) , type(fclDeviceFloat) , type(fclDeviceDouble) . nBytes ( integer ): number of bytes to allocated for an untyped buffer object. dim ( integer ): number of elements for which to allocate the typed buffer. profileName ( character(*) , optional ): descriptive name for printing profiling information. See profiling . access (one of 'r' , 'w' , 'rw' , optional ): kernel read/write access to buffer, default 'rw' . Note All buffer operations are submitted to the command queue specified at buffer initialisation. To change the command queue associated with a buffer use the syntax: buffer%cmdq => newCmdQ . Example: read-only integer buffer with 1000 elements type ( fclDeviceInt32 ) :: array_d call fclInitBuffer ( array_d , dim = 1000 , access = 'r' ) No command queue is specified, so the default command queue is used ( fclDefaultCmdQ ) which is assumed to have been initialised. 'Read only' in this context means that OpenCL kernels cannot write to this buffer. Example: read-write double precision buffer with command queue type ( fclDeviceDouble ) :: array_d type ( fclCmdQ ) :: cmdq ... call fclInitBuffer ( cmdq , array_d , dim = 1000 , profileName = 'array_d' ) API ref: fclInitBuffer , fclDeviceBuffer , fclDeviceInt32 , fclDeviceFloat , fclDeviceDouble","title":"1. Initialise device memory"},{"location":"memory/#2-fill-device-buffer-with-scalar","text":"The assignment = operator can be used to fill an initialised device buffer with a scalar value. Example type ( fclDeviceFloat ) :: deviceFloat type ( fclDevicDouble ) :: deviceDouble ... ! Initialise device arrays call fclInitBuffer ( deviceFloat , Nelem ) call fclInitBuffer ( deviceDouble , Nelem ) ! Fill arrays with zeros deviceFloat = 0.0 deviceDouble = 0.0d0 Note Since filling an array with a scalar value does not involve a host array pointer, it is non-blocking . The scalar assignment is enqueued onto the command queue and host code continues. Call fclWait(cmdq%lastWriteEvent) to wait. API ref: Assignment(=)","title":"2. Fill device buffer with scalar"},{"location":"memory/#3-data-transfer-between-device-and-host","text":"Data transfer between a device buffer and a host array can be achieved using the assignment = operation. When transferring data, the host and device arrays must be of compatible types. Example : transfer from host to device real ( real32 ) :: hostArray ( Nelem ) type ( fclDeviceFloat ) :: deviceArray ... ! Initialise device array call fclInitBuffer ( deviceArray , Nelem ) ! Copy to device from host deviceArray = hostArray Note Since transferring arrays involves a host array pointer, it is blocking by default. Host code does not continue until transfer completes. Set command queue blockingWrite and blockingRead to .false. for asynchronous transfers. Example: Non-blocking data transfer To perform non-blocking transfer, we set the command queue parameter variables blockingWrite and blockingRead to .false. as required. To keep track of the transfer operations we can use the command queue variables lastWriteEvent and lastReadEvent or the global variables fclLastWriteEvent and fclLastReadEvent . type ( fclEvent ) :: e ... cmdq % blockingWrite = . false . ! Enable non-blocking host-to-device transfers deviceArray = hostArray ! Enqueue the transfer command e = cmdq % lastWriteEvent ! Get transfer event object ... call fclWait ( e ) ! Wait for event when needed If using the default command queue then replace cmdq with fclDefaultCmdQ . API ref: Assignment(=) , fclCommandQ , fclWait","title":"3. Data transfer between device and host"},{"location":"memory/#4-transfer-device-array-to-device-array","text":"Device arrays and device array pointers can also be copied using the assignment = operator. If both the source object (right value) and target object (left value) are valid initialised device array objects, then the assignment operation will enqueue a non-blocking device-to-device transfer. This event can be waited upon by the host using fclWait(cmdq%lastCopyEvent) . If the target object (left value) is not initialised then the assignment operation will copy the pointer from the initialised source object (right value) such that both objects refer to the same device array. If the source object (right value) is not initialised then the assignment operation is invalid and will result in a runtime error. Example type ( fclDeviceInt32 ) :: deviceArray1 type ( fclDeviceInt32 ) :: deviceArray2 ... ! Initialise device array 1 call fclInitBuffer ( deviceArray1 , Nelem ) deviceArray2 = deviceArray1 ! deviceArray2 and deviceArray1 now reference the same device buffer Example type ( fclDeviceInt32 ) :: deviceArray1 type ( fclDeviceInt32 ) :: deviceArray2 ... ! Initialise both device arrays call fclInitBuffer ( deviceArray1 , Nelem ) call fclInitBuffer ( deviceArray2 , Nelem ) ... deviceArray2 = deviceArray1 call fclWait ( fclLastCopyEvent ) ! Contents of deviceArray1 copied to deviceArray2 API ref: Assignment(=) , fclCommandQ , fclWait","title":"4. Transfer device array to device array"},{"location":"memory/#5-swap-buffer-pointers","text":"Device buffer pointers can be swapped on the host using fclBufferSwap . This can be more efficient than performing a device-to-device copy. Example integer :: i type ( fclKernel ) :: myKernel type ( fclDeviceFloat ) :: a1_d , a2_d ... do i = 1 , 10 call myKernel % launch ( a1_d ) ... call fclBufferSwap ( a1_d , a2_d ) end do","title":"5. Swap buffer pointers"},{"location":"memory/#6-free-device-memory","text":"Device memory is released using fclFreeBuffer . Example call fclFreeBuffer ( deviceArray ) API ref: fclFreeBuffer","title":"6. Free device memory"},{"location":"profiling/","text":"Profiling OpenCL code in Focal OpenCL has a built in event profiling functionality whereby timings are available for enqueued operations. This functionality can be handled automatically in Focal by enabling profiling on kernel and buffer objects. When enabled, kernel launch events and buffer transfer events are 'recorded' for which timing information can be later extracted and processed. Example program: nbody.f90 1. Standard: Use a profiler object An fclProfiler type is provided to simplify the extraction of profiling data. This type simply represents a collection of kernels and buffers for which you wish to generate profiling data. A set of routines are provided to extract and present profiling data for all kernels and buffers in a particular profiler object. 1.1 Define a profiler To start, we must define a profiler object and set the device it is associated with: Assuming we have a context ctx and we have a device list devices (see Setup: Querying devices ) from which we are going to use the first device, then we set the profiler device as follows: type ( fclProfiler ) :: profiler type ( fclDevice ), allocatable :: devices (:) ... devices = fclFindDevices ( ctx , type = 'cpu' , sortBy = 'cores' ) profiler % device = devices ( 1 ) API ref: fclProfiler 1.2 Enable profiling on kernels and buffers Once we have a profiler with an associated device and have initialised our kernels and buffers, we can enable profiling with the following interfaces: Interface: call fclProfilerAdd ( < fclProfiler > , profileSize =< int > , < fclKernel | fclBuffer > ,...) or equivalently: call < fclProfiler > % add ( profileSize =< int > , < fclKernel | fclBuffer > ,...) Both interface formats are equivalent. profileSize specifies the amount of space to allocate for recording events: set to the number of events you wish to record. If more events occur than space allocated, then 'old' events are simply overridden. i.e. only the last profileSize events are recorded. Up to 10 kernel or buffer objects can be passed as arguments after profileSize . The same profile size is allocated for each kernel or buffer specified. Example: type ( fclProfiler ) :: profiler type ( fclKernel ) :: myKernel1 , myKernel2 type ( fclDeviceInt32 ) :: buffer1 type ( fclDeviceInt32 ) :: buffer2 ... profiler % add ( 100 , myKernel1 , myKernel2 ) profiler % add ( 10 , buffer1 , buffer2 ) In this example, we enable profiling for both kernels with space for 100 events and, in a separate call, we enable profiling for two buffer objects with space for 10 events. Note If intending to profile a buffer object, make sure you specify a profileName when initialising the buffer so that the profiler can print it in the output. API ref: fclProfilerAdd 1.3 Print out profiling data summary Once your OpenCL program has completed and all events are finished (see host synchronisation ), we can use the command fclDumpProfileData with our profiler object to extract and display profiling results. Interface: call fclDumpProfileData ( < fclProfiler > , outputUnit =< int > ) The first argument is the profiler object for which we wish to print out data for. outputUnit is an optional integer argument to specify an open file unit to which to print profiling data summary. If omitted then stdout is used and data is printed to the screen. Example: type ( fclProfiler ) :: profiler ... call fclWait () call fclDumpProfileData ( profiler ) The following is an example of output from fclDumpProfileData : ----------------------------------------------------------------------------- Profile name| No. of| T_avg| T_max| T_min| Local|Privat|PWGS (Kernel)| events| (ns)| (ns)| (ns)| Mem.| Mem.| ----------------------------------------------------------------------------- initialise| 1| 308750| 308750| 308750| 0| 0| 32 collide| 5000| 846595| 1527166| 735833| 0| 0| 32 boundaryConditions| 5000| 154161| 234083| 131333| 0| 0| 32 stream| 5000| 1067590| 1419500| 921000| 0| 0| 32 macroVars| 50| 897174| 1104250| 802833| 0| 0| 32 ----------------------------------------------------------------------------- ns: nanoseconds, PWGS: Preferred work group size, Mem: Memory in bytes. ----------------------------------------------------------------------------- ----------------------------------------------------------------------------- Profile name| No. of| Size|Transfer| S_avg| S_max| S_min (Buffer)| events|(KBytes)| mode| (GB/S)| (GB/S)| (GB/S) ----------------------------------------------------------------------------- rho_d| 50| 640| READ | 15.2255| 20.7570| 6.9565 u_d| 50| 640| READ | 14.3151| 18.7777| 7.3074 v_d| 50| 640| READ | 11.1791| 15.3909| 6.0425 bcFlags_d| 1| 640| WRITE| 9.3842| 9.3842| 9.3842 ----------------------------------------------------------------------------- API ref: fclDumpProfileData 1.4 Generate a chrome tracing file The Google Chrome web browser has a built-in profiler which can load and display any arbitrary profiling data as long as it is in the expected JSON format . The fclDumpTracingData routine is provided to generate such JSON files for use with chrome tracing. Interface: call fclDumpTracingData ( < fclProfiler > , filename =< character ( * ) > ) Example: type ( fclProfiler ) :: profiler ... call fclWait () call fclDumpTracingData ( profiler , 'trace.json' ) API ref: fclDumpTracingData 2. Advanced: Get timings explicitly 2.1 Enable profiling without a profiler object The fclProfiler type provides a convenient interface for producing aggregate profiling information for a collection of kernels and buffers. However a profiler object is not required if you want to access profiling data directly. To enable profiling on a kernel or buffer directly, use fclEnableProfiling . Interfaces: call fclEnableProfiling ( < fclKernel > , profileSize =< int > ) call fclEnableProfiling ( < fclBuffer > , profileSize =< int > ) Example: type ( fclKernel ) :: myKernel type ( fclDeviceFloat ) :: myBuffer ... call fclEnableProfiling ( myKernel , 100 ) call fclEnableProfiling ( myBuffer , 50 ) API ref: fclEnableProfiling 2.2 Extract event durations To access profiling data directly, use the command fclGetEventDurations and pass in the profileEvents component of the kernel or buffer object. This will return an integer array where each entry corresponds to the duration in nanoseconds of an event in the input array. Interface < integer (:) > = fclGetEventDurations ( eventList =< fclEvent (:) > ) Example integer , parameter :: Nprofile type ( fclKernel ) :: myKernel integer :: durations ( Nprofile ) real :: averageTime ... myKernel = fclGetProgramKernel ( prog , kernelName = 'sum' , profileSize = Nprofile ) ... durations = fclGetEventDurations ( myKernel % profileEvents (:)) averageTime = sum ( durations ) / Nprofile API ref: fclGetEventDurations","title":"Profiling OpenCL code in Focal"},{"location":"profiling/#profiling-opencl-code-in-focal","text":"OpenCL has a built in event profiling functionality whereby timings are available for enqueued operations. This functionality can be handled automatically in Focal by enabling profiling on kernel and buffer objects. When enabled, kernel launch events and buffer transfer events are 'recorded' for which timing information can be later extracted and processed. Example program: nbody.f90","title":"Profiling OpenCL code in Focal"},{"location":"profiling/#1-standard-use-a-profiler-object","text":"An fclProfiler type is provided to simplify the extraction of profiling data. This type simply represents a collection of kernels and buffers for which you wish to generate profiling data. A set of routines are provided to extract and present profiling data for all kernels and buffers in a particular profiler object.","title":"1. Standard: Use a profiler object"},{"location":"profiling/#11-define-a-profiler","text":"To start, we must define a profiler object and set the device it is associated with: Assuming we have a context ctx and we have a device list devices (see Setup: Querying devices ) from which we are going to use the first device, then we set the profiler device as follows: type ( fclProfiler ) :: profiler type ( fclDevice ), allocatable :: devices (:) ... devices = fclFindDevices ( ctx , type = 'cpu' , sortBy = 'cores' ) profiler % device = devices ( 1 ) API ref: fclProfiler","title":"1.1 Define a profiler"},{"location":"profiling/#12-enable-profiling-on-kernels-and-buffers","text":"Once we have a profiler with an associated device and have initialised our kernels and buffers, we can enable profiling with the following interfaces: Interface: call fclProfilerAdd ( < fclProfiler > , profileSize =< int > , < fclKernel | fclBuffer > ,...) or equivalently: call < fclProfiler > % add ( profileSize =< int > , < fclKernel | fclBuffer > ,...) Both interface formats are equivalent. profileSize specifies the amount of space to allocate for recording events: set to the number of events you wish to record. If more events occur than space allocated, then 'old' events are simply overridden. i.e. only the last profileSize events are recorded. Up to 10 kernel or buffer objects can be passed as arguments after profileSize . The same profile size is allocated for each kernel or buffer specified. Example: type ( fclProfiler ) :: profiler type ( fclKernel ) :: myKernel1 , myKernel2 type ( fclDeviceInt32 ) :: buffer1 type ( fclDeviceInt32 ) :: buffer2 ... profiler % add ( 100 , myKernel1 , myKernel2 ) profiler % add ( 10 , buffer1 , buffer2 ) In this example, we enable profiling for both kernels with space for 100 events and, in a separate call, we enable profiling for two buffer objects with space for 10 events. Note If intending to profile a buffer object, make sure you specify a profileName when initialising the buffer so that the profiler can print it in the output. API ref: fclProfilerAdd","title":"1.2 Enable profiling on kernels and buffers"},{"location":"profiling/#13-print-out-profiling-data-summary","text":"Once your OpenCL program has completed and all events are finished (see host synchronisation ), we can use the command fclDumpProfileData with our profiler object to extract and display profiling results. Interface: call fclDumpProfileData ( < fclProfiler > , outputUnit =< int > ) The first argument is the profiler object for which we wish to print out data for. outputUnit is an optional integer argument to specify an open file unit to which to print profiling data summary. If omitted then stdout is used and data is printed to the screen. Example: type ( fclProfiler ) :: profiler ... call fclWait () call fclDumpProfileData ( profiler ) The following is an example of output from fclDumpProfileData : ----------------------------------------------------------------------------- Profile name| No. of| T_avg| T_max| T_min| Local|Privat|PWGS (Kernel)| events| (ns)| (ns)| (ns)| Mem.| Mem.| ----------------------------------------------------------------------------- initialise| 1| 308750| 308750| 308750| 0| 0| 32 collide| 5000| 846595| 1527166| 735833| 0| 0| 32 boundaryConditions| 5000| 154161| 234083| 131333| 0| 0| 32 stream| 5000| 1067590| 1419500| 921000| 0| 0| 32 macroVars| 50| 897174| 1104250| 802833| 0| 0| 32 ----------------------------------------------------------------------------- ns: nanoseconds, PWGS: Preferred work group size, Mem: Memory in bytes. ----------------------------------------------------------------------------- ----------------------------------------------------------------------------- Profile name| No. of| Size|Transfer| S_avg| S_max| S_min (Buffer)| events|(KBytes)| mode| (GB/S)| (GB/S)| (GB/S) ----------------------------------------------------------------------------- rho_d| 50| 640| READ | 15.2255| 20.7570| 6.9565 u_d| 50| 640| READ | 14.3151| 18.7777| 7.3074 v_d| 50| 640| READ | 11.1791| 15.3909| 6.0425 bcFlags_d| 1| 640| WRITE| 9.3842| 9.3842| 9.3842 ----------------------------------------------------------------------------- API ref: fclDumpProfileData","title":"1.3 Print out profiling data summary"},{"location":"profiling/#14-generate-a-chrome-tracing-file","text":"The Google Chrome web browser has a built-in profiler which can load and display any arbitrary profiling data as long as it is in the expected JSON format . The fclDumpTracingData routine is provided to generate such JSON files for use with chrome tracing. Interface: call fclDumpTracingData ( < fclProfiler > , filename =< character ( * ) > ) Example: type ( fclProfiler ) :: profiler ... call fclWait () call fclDumpTracingData ( profiler , 'trace.json' ) API ref: fclDumpTracingData","title":"1.4 Generate a chrome tracing file"},{"location":"profiling/#2-advanced-get-timings-explicitly","text":"","title":"2. Advanced: Get timings explicitly"},{"location":"profiling/#21-enable-profiling-without-a-profiler-object","text":"The fclProfiler type provides a convenient interface for producing aggregate profiling information for a collection of kernels and buffers. However a profiler object is not required if you want to access profiling data directly. To enable profiling on a kernel or buffer directly, use fclEnableProfiling . Interfaces: call fclEnableProfiling ( < fclKernel > , profileSize =< int > ) call fclEnableProfiling ( < fclBuffer > , profileSize =< int > ) Example: type ( fclKernel ) :: myKernel type ( fclDeviceFloat ) :: myBuffer ... call fclEnableProfiling ( myKernel , 100 ) call fclEnableProfiling ( myBuffer , 50 ) API ref: fclEnableProfiling","title":"2.1 Enable profiling without a profiler object"},{"location":"profiling/#22-extract-event-durations","text":"To access profiling data directly, use the command fclGetEventDurations and pass in the profileEvents component of the kernel or buffer object. This will return an integer array where each entry corresponds to the duration in nanoseconds of an event in the input array. Interface < integer (:) > = fclGetEventDurations ( eventList =< fclEvent (:) > ) Example integer , parameter :: Nprofile type ( fclKernel ) :: myKernel integer :: durations ( Nprofile ) real :: averageTime ... myKernel = fclGetProgramKernel ( prog , kernelName = 'sum' , profileSize = Nprofile ) ... durations = fclGetEventDurations ( myKernel % profileEvents (:)) averageTime = sum ( durations ) / Nprofile API ref: fclGetEventDurations","title":"2.2 Extract event durations"},{"location":"quickstart/","text":"Quickstart Guide See build and linking first on how to build the library and subsequently link against it. 1. Choose a device and initialise OpenCL context We can quickly initialse an OpenCL context with a specific device using the fclInit function. This functions allows us to filter and sort available devices based on their properties and choose one of them to work with. Example: type ( fclDevice ) :: device ... device = fclInit ( vendor = 'nvidia,amd' , type = 'gpu' , sortBy = 'cores' ) In this example we have specified any gpu device belonging to vendors nvidia OR amd and to choose the device with the most compute units ( cores ). We can alternatively sort devices by total global memory ( sortBy='memory' ) or by maximum clock speed ( sortBy='clock' ). Additional filter fields which can be used are: extensions to filter based on supported OpenCL extensions; and nameLike to filter based on the name of the device. Example: type ( fclDevice ) :: device ... device = fclInit ( type = 'gpu' , nameLike = 'tesla' , sortBy = 'memory' ) If the function is able to find a device matching the criteria, then it initialises an OpenCL context on the corresponding platform and returns an fclDevice object on which we can create command queues. See User guide/Setup for more detail on querying available platforms and devices with Focal and advanced methods for setting up OpenCL contexts and using multiple devices. 2. Create a command queue Once we have an fclDevice object for our chosen device, we can create a command queue on it which will be used to issue operations to the device: type ( fclDevice ) :: device type ( fclCommandQ ) :: cmdq ... cmdq = fclCreateCommandQ ( device ) The resulting command queue object cmdq can be passed to subsequent commands to specify which command queue to use. However, a common command queue called the default command queue exists within Focal which when set allows you to omit the command queue object in subsequent Focal commands. To create a command queue and set as the default command queue: call fclSetDefaultCommandQ ( fclCreateCommandQ ( device ) ) With this syntax, we can omit the command queue variable ( cmdq ) in subsequent focal calls. See User guide/Setup for more details on creating command queues. 3. Load and compile a kernel A utility function fclSourceFromFile is provided to load text from file into an allocatable Fortran character(:) string: character (:), allocatable :: programSource ... call fclSourceFromFile ( 'kernels.cl' , programSource ) Here programSource is a string containing a collection of OpenCL kernels. OpenCL programs are compiled at runtime - this allows perfect portability since the kernels will always be compiled for the local available hardware. In Focal we use the fclCompileProgram command to compile the OpenCL program before using the fclGetProgramKernel to extract a kernel object for the particular kernel we are interested in: type ( fclProgram ) :: prog type ( fclKernel ) :: myKernel ... prog = fclCompileProgram ( programSource ) myKernel = fclGetProgramKernel ( prog , 'kernelName' , global_work_size = [ 1000 ]) The optional third argument specifies the global work dimensions for the kernel; here we have specified a one-dimensional global work set with 1000 elements. Additional optional arguments here can include local_work_size , work_dim and global_work_offset . Additionally, these kernel attributes can be set using the syntax: myKernel % global_work_size = [ 100 , 100 ] myKernel % work_dim = 2 myKernel % local_work_size = [ 10 , 10 ] myKernel % global_work_offset = [ 50 , 50 ] See User guide/Kernels for more details on compiling and extracting kernels. 4. Initialise device memory buffers OpenCL kernels operate on memory residing on the device. We must therefore declare and initialise data buffers on the device. In the following example we initialise a 32bit integer array with 1000 values on the command queue cmdq : type ( fclDeviceInt32 ) :: deviceArray ... call fclInitBuffer ( cmdq , deviceArray , dim = 1000 ) Note All future buffer operations (transfers to/from device and copying on device) will be issued to the command queue cmdq specified here. If the default command queue has been set and you wish to use it for this buffer, then cmdq can be omitted in the call to fclInitBuffer : type ( fclDeviceInt32 ) :: deviceArray ... call fclInitBuffer ( deviceArray , dim = 1000 ) Other supported types are fclDeviceFloat and fclDeviceDouble . Once the device buffers have been initialised, we can transfer data to them. In Focal this is done simply with an assignment statement: integer :: hostArray ( 1000 ) ... deviceArray = hostArray Note Focal transfer operations are only supported if the host array and device array are of compatible type and dimension. If the host array and device array are not of compatible type, then a compile-time error will occur. If the host array and device array are not of the same dimension, then a run-time error will occur. In a similar way, data can be transferred from the device back to the host: hostArray = deviceArray as well as copying between two buffers residing on the device: type ( fclDeviceFloat ) :: deviceArray1 , deviceArray2 ... deviceArray1 = deviceArray2 Note By default, transfer operations involving a host array are blocking : host code does not continue until the transfer has completed. See User guide/Memory for more details on managing memory. 5. Launch a kernel We are now ready to launch a kernel. Using the kernel object myKernel extracted previously, this can then be launched on command queue cmdq with the syntax: call myKernel % launch ( cmdq , 1000 , deviceArray ) Again, cmdq can be omitted here if you wish to use the default command queue assuming it has been set. Here we have passed two arguments to the kernel: the scalar integer 1000 and the device array deviceArray . See User guide/Kernels for more details.","title":"Quickstart Guide"},{"location":"quickstart/#quickstart-guide","text":"See build and linking first on how to build the library and subsequently link against it.","title":"Quickstart Guide"},{"location":"quickstart/#1-choose-a-device-and-initialise-opencl-context","text":"We can quickly initialse an OpenCL context with a specific device using the fclInit function. This functions allows us to filter and sort available devices based on their properties and choose one of them to work with. Example: type ( fclDevice ) :: device ... device = fclInit ( vendor = 'nvidia,amd' , type = 'gpu' , sortBy = 'cores' ) In this example we have specified any gpu device belonging to vendors nvidia OR amd and to choose the device with the most compute units ( cores ). We can alternatively sort devices by total global memory ( sortBy='memory' ) or by maximum clock speed ( sortBy='clock' ). Additional filter fields which can be used are: extensions to filter based on supported OpenCL extensions; and nameLike to filter based on the name of the device. Example: type ( fclDevice ) :: device ... device = fclInit ( type = 'gpu' , nameLike = 'tesla' , sortBy = 'memory' ) If the function is able to find a device matching the criteria, then it initialises an OpenCL context on the corresponding platform and returns an fclDevice object on which we can create command queues. See User guide/Setup for more detail on querying available platforms and devices with Focal and advanced methods for setting up OpenCL contexts and using multiple devices.","title":"1. Choose a device and initialise OpenCL context"},{"location":"quickstart/#2-create-a-command-queue","text":"Once we have an fclDevice object for our chosen device, we can create a command queue on it which will be used to issue operations to the device: type ( fclDevice ) :: device type ( fclCommandQ ) :: cmdq ... cmdq = fclCreateCommandQ ( device ) The resulting command queue object cmdq can be passed to subsequent commands to specify which command queue to use. However, a common command queue called the default command queue exists within Focal which when set allows you to omit the command queue object in subsequent Focal commands. To create a command queue and set as the default command queue: call fclSetDefaultCommandQ ( fclCreateCommandQ ( device ) ) With this syntax, we can omit the command queue variable ( cmdq ) in subsequent focal calls. See User guide/Setup for more details on creating command queues.","title":"2. Create a command queue"},{"location":"quickstart/#3-load-and-compile-a-kernel","text":"A utility function fclSourceFromFile is provided to load text from file into an allocatable Fortran character(:) string: character (:), allocatable :: programSource ... call fclSourceFromFile ( 'kernels.cl' , programSource ) Here programSource is a string containing a collection of OpenCL kernels. OpenCL programs are compiled at runtime - this allows perfect portability since the kernels will always be compiled for the local available hardware. In Focal we use the fclCompileProgram command to compile the OpenCL program before using the fclGetProgramKernel to extract a kernel object for the particular kernel we are interested in: type ( fclProgram ) :: prog type ( fclKernel ) :: myKernel ... prog = fclCompileProgram ( programSource ) myKernel = fclGetProgramKernel ( prog , 'kernelName' , global_work_size = [ 1000 ]) The optional third argument specifies the global work dimensions for the kernel; here we have specified a one-dimensional global work set with 1000 elements. Additional optional arguments here can include local_work_size , work_dim and global_work_offset . Additionally, these kernel attributes can be set using the syntax: myKernel % global_work_size = [ 100 , 100 ] myKernel % work_dim = 2 myKernel % local_work_size = [ 10 , 10 ] myKernel % global_work_offset = [ 50 , 50 ] See User guide/Kernels for more details on compiling and extracting kernels.","title":"3. Load and compile a kernel"},{"location":"quickstart/#4-initialise-device-memory-buffers","text":"OpenCL kernels operate on memory residing on the device. We must therefore declare and initialise data buffers on the device. In the following example we initialise a 32bit integer array with 1000 values on the command queue cmdq : type ( fclDeviceInt32 ) :: deviceArray ... call fclInitBuffer ( cmdq , deviceArray , dim = 1000 ) Note All future buffer operations (transfers to/from device and copying on device) will be issued to the command queue cmdq specified here. If the default command queue has been set and you wish to use it for this buffer, then cmdq can be omitted in the call to fclInitBuffer : type ( fclDeviceInt32 ) :: deviceArray ... call fclInitBuffer ( deviceArray , dim = 1000 ) Other supported types are fclDeviceFloat and fclDeviceDouble . Once the device buffers have been initialised, we can transfer data to them. In Focal this is done simply with an assignment statement: integer :: hostArray ( 1000 ) ... deviceArray = hostArray Note Focal transfer operations are only supported if the host array and device array are of compatible type and dimension. If the host array and device array are not of compatible type, then a compile-time error will occur. If the host array and device array are not of the same dimension, then a run-time error will occur. In a similar way, data can be transferred from the device back to the host: hostArray = deviceArray as well as copying between two buffers residing on the device: type ( fclDeviceFloat ) :: deviceArray1 , deviceArray2 ... deviceArray1 = deviceArray2 Note By default, transfer operations involving a host array are blocking : host code does not continue until the transfer has completed. See User guide/Memory for more details on managing memory.","title":"4. Initialise device memory buffers"},{"location":"quickstart/#5-launch-a-kernel","text":"We are now ready to launch a kernel. Using the kernel object myKernel extracted previously, this can then be launched on command queue cmdq with the syntax: call myKernel % launch ( cmdq , 1000 , deviceArray ) Again, cmdq can be omitted here if you wish to use the default command queue assuming it has been set. Here we have passed two arguments to the kernel: the scalar integer 1000 and the device array deviceArray . See User guide/Kernels for more details.","title":"5. Launch a kernel"},{"location":"setup/","text":"Setup All OpenCL actions occur via contexts, which are containers for related devices, and command queues which are attached to specific devices. Each context is associated with a specific platform where a platform generally coincides with a particular vendor. 1a. Quick setup We can use the fclInit function to quickly select a device based on criteria from all devices available on the system. If a device matching the specified criteria is found, then this device is returned as an object and the default context is set using the platform containing the matching device. Interface: device = fclInit ([ vendor ],[ type ],[ nameLike ],[ extensions ],[ sortBy ]) device ( type(fclDevice) ): the chosen device returned by the function. vendor ( character(*) , optional ): if specified, look for this (sub)string in the device vendor to filter available devices. type (one of 'cpu' or 'gpu' , optional ): if specified, filter available devices based on device type. nameLike ( character(*) , optional ): if specified, look for this (sub)string in the device name to filter available devices. extensions ( character(*) , optional ): if specified, look for these OpenCL extensions (command-separated) to filter available devices; any device that does not support all extensions specified will be filtered out. sortBy (one of 'core' , 'memory' , 'clock' , optional ): from the filtered list, choose the device with the most compute units or total memory or clock speed. Example: type ( fclDevice ) :: device ... device = fclInit ( vendor = 'nvidia,amd' , type = 'gpu' , sortBy = 'cores' ) In this example we have specified any gpu device belonging to vendors nvidia OR amd and to choose the device with the most compute units ( cores ). Note fclInit automatically creates an OpenCL context for the chosen device and uses it to set the default context . By setting the default context, subsequent Focal API calls can omit the context ( 'ctx' ) argument. To add more devices from the same vendor, see fclFindDevices below. Jump down to command queues to now create a command queue on your chosen device 1b. Advanced setup Querying platforms OpenCL is able to support multiple different implementations on the same host using a platform model. An OpenCL platform is a specific OpenCL implementation; in general, platforms coincide with different hardware vendors. For example, if your machine has an Intel CPU and an NVIDIA graphics card both with drivers supporting OpenCL, then you will have two platforms available: one each for Intel and NVIDIA. We can get a list of platforms using the Focal subroutine fclGetPlatforms() . This returns a list of Focal fclPlatform objects: type ( fclPlatform ), pointer :: platforms (:) platforms => fclGetPlatforms () The Focal platform object contains fields such as name , vendor , version , and numDevice which we can use to select a particular platform. API ref: fclPlatform , fclGetPlatforms , fclGetPlatformInfo Create a context We can explicitly create an OpenCL context with a particular platform or vendor using fclCreateContext : There are two ways of calling this function, either with a platform object (see fclGetPlatforms() above to query platforms) or with a vendor string to specify the desired vendor: Interface: ctx = fclCreateContext ( platform ) ctx = fclCreateContext ( vendor ) ctx ( type(fclContext) ): context object returned. platform ( type(fclPlatform) ): a Focal platform object on which to create the context. vendor ( character(*) ): string or comma-separate list of strings to select a particular device vendor. If multiple vendors are specified, then the first vendor in the list that is found on the system is chosen, i.e. specify vendors in order of preference. Example: type ( fclContext ) :: ctx ... ctx = fclCreateContext ( 'nvidia,intel' ) In this example we create a context with first preference 'nvidia' and second preference 'intel' as device vendors. The default context Once created, the resulting context object (called ctx above) is used in subsequent Focal calls to indicate which context to use. If you are only using one context throughout your program, then your code can be simplified by setting the default context . This is a global variable which allows Focal calls to omit the context variable. In the following examples, we query devices in a context for GPUs; the first example uses an explicit context variable ctx whereas the second example calls fclSetDefaultContext and is able to omit the context variable in the call to fclFindDevices . Example: with explicit context variable type ( fclContext ) :: ctx type ( fclDevice ), allocatable :: devices (:) ... ctx = fclCreateContext ( vendor = 'nvidia' ) devices = fclFindDevices ( ctx , type = 'gpu' ) Example: with default context type ( fclDevice ), allocatable :: devices (:) ... call fclSetDefaultContext ( fclCreateContext ( vendor = 'nvidia' ) ) devices = fclFindDevices ( type = 'gpu' ) API ref: fclPlatform , fclSetDefaultContext , fclDefaultCtx Query devices on the context A useful way of querying available devices in a context is provided by the fclFindDevices function which enables us to filter the device list based on device type, device name as well as sort the list according to device properties. Interface: devices = fclFindDevices ( ctx ,[ type ],[ nameLike ],[ extensions ],[ sortBy ]) devices = fclFindDevices ([ type ],[ nameLike ],[ extensions ],[ sortBy ]) where arguments type , nameLike , extensions , and sortBy have the same definitions as defined for fclInit above. devices ( type(fclDevice) , allocatable ): an array of devices allocated on assignment. ctx ( type(fclContext) , optional ): the context from which to query available devices. The default context is used if this argument is omitted. Example: List CPUs in context ctx sorted (descending) by number of cores: type ( fclContext ) :: ctx type ( fclDevice ), allocatable :: devices (:) ... devices = fclFindDevices ( ctx , type = 'cpu' , sortBy = 'cores' ) Example: List GPUs in the default context where the name contains 'tesla' (case insensitive): type ( fcLDevice ), allocatable :: devices (:) ... devices = fclFindDevices ( type = 'gpu' , nameLike = 'tesla' ) From this list we can choose the first one or more devices as required. We can further query device properties using fclGetDeviceInfo (this requires inclusion of the clfortran module which defines values for the property key argument). API ref: fclFindDevices , fclGetDeviceInfo fclDevice 2. Creating a command queue Once a context created, and a device selected (see above) we can create an OpenCL command queue; all device actions are submitted via command queues. Command queues are associated with individual devices where one device can have multiple command queues (but not vice versa). Command queues are created using the fclCreateCommandQ function. Interface cmdq = fclCreateCommandQ ( ctx , device ,[ enableProfiling ],[ outOfOrderExec ], & [ blockingRead ], [ blockingWrite ]) cmdq = fclCreateCommandQ ( device ,[ enableProfiling ],[ outOfOrderExec ], & [ blockingRead ], [ blockingWrite ]) cmdq ( type(fclCommandQ) ): the created command queue object ctx ( type(fclContext) , optional ), the context associated with device . If no context is specified, then the default context is used. device ( type(fclDevice) ): the device on which to create the command queue. enableProfiling ( logical , optional ): whether to enable event profiling on this command queue, default .false. outOfOrderExec ( logical , optional ): whether to enable out-of-order execution on this command queue, default .false. blockingRead ( logical , optional ): whether memory read operations are host-blocking on this command queue, default .true. blockingWRite ( logical , optional ): whether memory write operations are host-blocking on this command queue, default .true. Example: Create command queue on first device in devices list with profiling enabled. type ( fclCommandQ ) :: cmdq ... cmdq = fclCreateCommandQ ( devices ( 1 ), enableProfiling = . true .) API ref: fclCreateCommandQ , fclCommandQ 2.1 The default command queue Once created, the resulting command queue object (called cmdq above) is used in subsequent Focal calls to indicate which device to use. In a similar way to the default context, a default command queue is provided to allow subsequent focal calls to omit the command queue object. This is useful if you are only using one command queue throughout your program. Example Set the default command queue on first device in devices list. call fclSetDefaultCommandQ ( fclCreateCommandQ ( devices ( 1 )) ) API ref: fclSetDefaultCommandQ , fclDefaultCommandQ 2.2 Command queue pools Many devices support multiple harware queues which allow different kernel and memory operations to be processed concurrently; this is particularly important when wanting to overlap memory transfers with compute operations or when individual compute kernels do not fully utilise the device compute units. OpenCL allows multiple command queues to be created for a single device; if the device supports multiple hardware queues, then the OpenCL command queues will map in some way to the available hardware queues. If not supported then the command queue work will be serialised on the device Note You can use the tracing functionality to visually check for kernel/memory runtime concurrency. Focal provides a fclCommandQPool type which performs simple round-robin scheduling across multiple command queues. To create a command queue pool we can use the fclCreateCommandQPool command which accepts the same arguments are fcCreateCommandQ in addition to an argument N specifying the number of command queues to create. Interface cmdq = fclCreateCommandQPool ( ctx , N , device ,[ enableProfiling ],[ outOfOrderExec ], & [ blockingRead ], [ blockingWrite ]) cmdq = fclCreateCommandQPool ( N , device ,[ enableProfiling ],[ outOfOrderExec ], & N ( integer ): number of command queues to create within command queue pool. Once created we can use the methods next() and current() to return the next scheduled or currently selected command queues respectively. Example: type ( fclCommandQPool ) :: qPool ... qPool = fclCreateCommandQPool ( 3 , device ) do i = 1 , 3 kernel1 % launch ( qPool % next (), data ( i )) kernel2 % launch ( qPool % current (), data ( i )) end do In this example we launch two sequential kernels three times on three different command queues for three different sets of data. Note that the second kernel launches on the same queue as the first kernel and will hence be launched in sequence, but each iteration of the do loop increments the current queue using the next() method. API ref: fclCreateCommandQPool , fclCommandQPool","title":"Setup"},{"location":"setup/#setup","text":"All OpenCL actions occur via contexts, which are containers for related devices, and command queues which are attached to specific devices. Each context is associated with a specific platform where a platform generally coincides with a particular vendor.","title":"Setup"},{"location":"setup/#1a-quick-setup","text":"We can use the fclInit function to quickly select a device based on criteria from all devices available on the system. If a device matching the specified criteria is found, then this device is returned as an object and the default context is set using the platform containing the matching device. Interface: device = fclInit ([ vendor ],[ type ],[ nameLike ],[ extensions ],[ sortBy ]) device ( type(fclDevice) ): the chosen device returned by the function. vendor ( character(*) , optional ): if specified, look for this (sub)string in the device vendor to filter available devices. type (one of 'cpu' or 'gpu' , optional ): if specified, filter available devices based on device type. nameLike ( character(*) , optional ): if specified, look for this (sub)string in the device name to filter available devices. extensions ( character(*) , optional ): if specified, look for these OpenCL extensions (command-separated) to filter available devices; any device that does not support all extensions specified will be filtered out. sortBy (one of 'core' , 'memory' , 'clock' , optional ): from the filtered list, choose the device with the most compute units or total memory or clock speed. Example: type ( fclDevice ) :: device ... device = fclInit ( vendor = 'nvidia,amd' , type = 'gpu' , sortBy = 'cores' ) In this example we have specified any gpu device belonging to vendors nvidia OR amd and to choose the device with the most compute units ( cores ). Note fclInit automatically creates an OpenCL context for the chosen device and uses it to set the default context . By setting the default context, subsequent Focal API calls can omit the context ( 'ctx' ) argument. To add more devices from the same vendor, see fclFindDevices below. Jump down to command queues to now create a command queue on your chosen device","title":"1a. Quick setup"},{"location":"setup/#1b-advanced-setup","text":"","title":"1b. Advanced setup"},{"location":"setup/#querying-platforms","text":"OpenCL is able to support multiple different implementations on the same host using a platform model. An OpenCL platform is a specific OpenCL implementation; in general, platforms coincide with different hardware vendors. For example, if your machine has an Intel CPU and an NVIDIA graphics card both with drivers supporting OpenCL, then you will have two platforms available: one each for Intel and NVIDIA. We can get a list of platforms using the Focal subroutine fclGetPlatforms() . This returns a list of Focal fclPlatform objects: type ( fclPlatform ), pointer :: platforms (:) platforms => fclGetPlatforms () The Focal platform object contains fields such as name , vendor , version , and numDevice which we can use to select a particular platform. API ref: fclPlatform , fclGetPlatforms , fclGetPlatformInfo","title":"Querying platforms"},{"location":"setup/#create-a-context","text":"We can explicitly create an OpenCL context with a particular platform or vendor using fclCreateContext : There are two ways of calling this function, either with a platform object (see fclGetPlatforms() above to query platforms) or with a vendor string to specify the desired vendor: Interface: ctx = fclCreateContext ( platform ) ctx = fclCreateContext ( vendor ) ctx ( type(fclContext) ): context object returned. platform ( type(fclPlatform) ): a Focal platform object on which to create the context. vendor ( character(*) ): string or comma-separate list of strings to select a particular device vendor. If multiple vendors are specified, then the first vendor in the list that is found on the system is chosen, i.e. specify vendors in order of preference. Example: type ( fclContext ) :: ctx ... ctx = fclCreateContext ( 'nvidia,intel' ) In this example we create a context with first preference 'nvidia' and second preference 'intel' as device vendors.","title":"Create a context"},{"location":"setup/#the-default-context","text":"Once created, the resulting context object (called ctx above) is used in subsequent Focal calls to indicate which context to use. If you are only using one context throughout your program, then your code can be simplified by setting the default context . This is a global variable which allows Focal calls to omit the context variable. In the following examples, we query devices in a context for GPUs; the first example uses an explicit context variable ctx whereas the second example calls fclSetDefaultContext and is able to omit the context variable in the call to fclFindDevices . Example: with explicit context variable type ( fclContext ) :: ctx type ( fclDevice ), allocatable :: devices (:) ... ctx = fclCreateContext ( vendor = 'nvidia' ) devices = fclFindDevices ( ctx , type = 'gpu' ) Example: with default context type ( fclDevice ), allocatable :: devices (:) ... call fclSetDefaultContext ( fclCreateContext ( vendor = 'nvidia' ) ) devices = fclFindDevices ( type = 'gpu' ) API ref: fclPlatform , fclSetDefaultContext , fclDefaultCtx","title":"The default context"},{"location":"setup/#query-devices-on-the-context","text":"A useful way of querying available devices in a context is provided by the fclFindDevices function which enables us to filter the device list based on device type, device name as well as sort the list according to device properties. Interface: devices = fclFindDevices ( ctx ,[ type ],[ nameLike ],[ extensions ],[ sortBy ]) devices = fclFindDevices ([ type ],[ nameLike ],[ extensions ],[ sortBy ]) where arguments type , nameLike , extensions , and sortBy have the same definitions as defined for fclInit above. devices ( type(fclDevice) , allocatable ): an array of devices allocated on assignment. ctx ( type(fclContext) , optional ): the context from which to query available devices. The default context is used if this argument is omitted. Example: List CPUs in context ctx sorted (descending) by number of cores: type ( fclContext ) :: ctx type ( fclDevice ), allocatable :: devices (:) ... devices = fclFindDevices ( ctx , type = 'cpu' , sortBy = 'cores' ) Example: List GPUs in the default context where the name contains 'tesla' (case insensitive): type ( fcLDevice ), allocatable :: devices (:) ... devices = fclFindDevices ( type = 'gpu' , nameLike = 'tesla' ) From this list we can choose the first one or more devices as required. We can further query device properties using fclGetDeviceInfo (this requires inclusion of the clfortran module which defines values for the property key argument). API ref: fclFindDevices , fclGetDeviceInfo fclDevice","title":"Query devices on the context"},{"location":"setup/#2-creating-a-command-queue","text":"Once a context created, and a device selected (see above) we can create an OpenCL command queue; all device actions are submitted via command queues. Command queues are associated with individual devices where one device can have multiple command queues (but not vice versa). Command queues are created using the fclCreateCommandQ function. Interface cmdq = fclCreateCommandQ ( ctx , device ,[ enableProfiling ],[ outOfOrderExec ], & [ blockingRead ], [ blockingWrite ]) cmdq = fclCreateCommandQ ( device ,[ enableProfiling ],[ outOfOrderExec ], & [ blockingRead ], [ blockingWrite ]) cmdq ( type(fclCommandQ) ): the created command queue object ctx ( type(fclContext) , optional ), the context associated with device . If no context is specified, then the default context is used. device ( type(fclDevice) ): the device on which to create the command queue. enableProfiling ( logical , optional ): whether to enable event profiling on this command queue, default .false. outOfOrderExec ( logical , optional ): whether to enable out-of-order execution on this command queue, default .false. blockingRead ( logical , optional ): whether memory read operations are host-blocking on this command queue, default .true. blockingWRite ( logical , optional ): whether memory write operations are host-blocking on this command queue, default .true. Example: Create command queue on first device in devices list with profiling enabled. type ( fclCommandQ ) :: cmdq ... cmdq = fclCreateCommandQ ( devices ( 1 ), enableProfiling = . true .) API ref: fclCreateCommandQ , fclCommandQ","title":"2. Creating a command queue"},{"location":"setup/#21-the-default-command-queue","text":"Once created, the resulting command queue object (called cmdq above) is used in subsequent Focal calls to indicate which device to use. In a similar way to the default context, a default command queue is provided to allow subsequent focal calls to omit the command queue object. This is useful if you are only using one command queue throughout your program. Example Set the default command queue on first device in devices list. call fclSetDefaultCommandQ ( fclCreateCommandQ ( devices ( 1 )) ) API ref: fclSetDefaultCommandQ , fclDefaultCommandQ","title":"2.1 The default command queue"},{"location":"setup/#22-command-queue-pools","text":"Many devices support multiple harware queues which allow different kernel and memory operations to be processed concurrently; this is particularly important when wanting to overlap memory transfers with compute operations or when individual compute kernels do not fully utilise the device compute units. OpenCL allows multiple command queues to be created for a single device; if the device supports multiple hardware queues, then the OpenCL command queues will map in some way to the available hardware queues. If not supported then the command queue work will be serialised on the device Note You can use the tracing functionality to visually check for kernel/memory runtime concurrency. Focal provides a fclCommandQPool type which performs simple round-robin scheduling across multiple command queues. To create a command queue pool we can use the fclCreateCommandQPool command which accepts the same arguments are fcCreateCommandQ in addition to an argument N specifying the number of command queues to create. Interface cmdq = fclCreateCommandQPool ( ctx , N , device ,[ enableProfiling ],[ outOfOrderExec ], & [ blockingRead ], [ blockingWrite ]) cmdq = fclCreateCommandQPool ( N , device ,[ enableProfiling ],[ outOfOrderExec ], & N ( integer ): number of command queues to create within command queue pool. Once created we can use the methods next() and current() to return the next scheduled or currently selected command queues respectively. Example: type ( fclCommandQPool ) :: qPool ... qPool = fclCreateCommandQPool ( 3 , device ) do i = 1 , 3 kernel1 % launch ( qPool % next (), data ( i )) kernel2 % launch ( qPool % current (), data ( i )) end do In this example we launch two sequential kernels three times on three different command queues for three different sets of data. Note that the second kernel launches on the same queue as the first kernel and will hence be launched in sequence, but each iteration of the do loop increments the current queue using the next() method. API ref: fclCreateCommandQPool , fclCommandQPool","title":"2.2 Command queue pools"}]}